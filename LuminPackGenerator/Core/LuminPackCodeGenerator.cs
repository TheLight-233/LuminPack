using System.Collections.Generic;
using System.Text;
using System;
using System.Linq;
using System.Runtime.CompilerServices;
using LuminPack.SourceGenerator;

#nullable enable
namespace LuminPack.Code.Core
{

    public static class LuminPackCodeGenerator
    {
        private static LuminDataInfo? _dataInfo;
        
        static HashSet<string> defaultNamespace = new HashSet<string>()
        {
            "System",
            "System.Collections.Generic",
            "System.Runtime.CompilerServices",
            "System.Runtime.InteropServices",
            "System.Threading.Tasks",
            "LuminPack",
            "LuminPack.Data",
            "LuminPack.Code",
            "LuminPack.Core",
            "Your.Data.Namespace"
        };
        
        public static string CodeGenerator(LuminDataInfo data, MetaInfo metaInfo)
        {
            //缓存Info
            _dataInfo = data;
            
            string paraNullable = _dataInfo.isValueType ? string.Empty : "?";

            var isAllUnmanagedType = FindAllUnmanagedType(data.fields);
            
            StringBuilder sb = new StringBuilder();
            HashSet<string> namespaces = new HashSet<string>();

            if (_dataInfo.classNameSpace != "<global namespace>")
            {
                namespaces.Add(_dataInfo.classNameSpace);
            }
            
            // 收集需要的命名空间
            foreach (var field in data.fields)
            {
                if (!string.IsNullOrEmpty(field.NameSpace) &&
                    field.NameSpace != "Your Data NameSpace" &&
                    !field.NameSpace.Contains("<"))
                {
                    namespaces.Add(field.NameSpace);
                }

                if (field.ClassFields.Count > 0)
                {
                    foreach (var classField in field.ClassFields)
                    {
                        if (!string.IsNullOrEmpty(classField.NameSpace) &&
                            classField.NameSpace != "Your Data NameSpace")
                        {
                            namespaces.Add(classField.NameSpace);
                        }
                    }
                }
            }

            //Setting
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("#pragma warning disable CS0108 // hides inherited member");
            sb.AppendLine("#pragma warning disable CS0162 // Unreachable code");
            sb.AppendLine("#pragma warning disable CS0164 // This label has not been referenced");
            sb.AppendLine("#pragma warning disable CS0168 ");
            sb.AppendLine("#pragma warning disable CS0219 // Variable assigned but never used");
            sb.AppendLine("#pragma warning disable CS0618 // Type or member is obsolete");
            sb.AppendLine("#pragma warning disable CS0649 ");
            sb.AppendLine("#pragma warning disable CS8600 // Converting null literal or possible null value to non - nullable type.");
            sb.AppendLine("#pragma warning disable CS8601 // Possible null reference assignment");
            sb.AppendLine("#pragma warning disable CS8602");
            sb.AppendLine("#pragma warning disable CS8604 // Possible null reference argument for parameter");
            sb.AppendLine("#pragma warning disable CS8619");
            sb.AppendLine("#pragma warning disable CS8620");
            sb.AppendLine("#pragma warning disable CS8631 // The type cannot be used as type parameter in the generic type or method");
            sb.AppendLine("#pragma warning disable CS8765 // Nullability of type of parameter");
            sb.AppendLine("#pragma warning disable CS9074 // The 'scoped' modifier of parameter doesn't match overridden or implemented member");
            sb.AppendLine("#pragma warning disable CA1050 // Declare types in namespaces.");

            sb.AppendLine();
            sb.AppendLine();
            
            // 基础命名空间
            sb.AppendLine("using global::System;");
            sb.AppendLine("using global::System.Collections.Generic;");
            sb.AppendLine("using global::System.Runtime.CompilerServices;");
            sb.AppendLine("using global::System.Runtime.InteropServices;");
            sb.AppendLine("using global::System.Threading.Tasks;");
            sb.AppendLine("using global::LuminPack;");
            sb.AppendLine("using global::LuminPack.Data;");
            sb.AppendLine("using global::LuminPack.Code;");
            sb.AppendLine("using global::LuminPack.Core;");
            sb.AppendLine("using global::LuminPack.Parsers;");
            sb.AppendLine("using global::LuminPack.Utility;");
            sb.AppendLine("using global::LuminPack.Attribute;");
            
            if (data.enableBurst)
                sb.AppendLine("using global::Unity.Burst;");
            // 自定义命名空间
            foreach (var ns in namespaces)
            {
                if (!defaultNamespace.Contains(ns)) 
                    sb.AppendLine($"using global::{ns};");
            }

            sb.AppendLine();

            // 类定义
            sb.AppendLine($"//{data.generatorType.ToString()}");
            
            sb.AppendLine($"namespace {LuminPackSourceGenerator.LUMIN_GENERATED_NAMESPACE}");
            sb.AppendLine("{");

            string classFullName = data.className + "Parser";
            string classGlobalName = data.classFullName;
            string parserName = data.className + "Parser";
            if (data.isGeneric)
            {
                classFullName += $"<{_dataInfo.GenericParameters.FirstOrDefault()}";
                for(var i = 1; i < data.GenericParameters.Count; i++)
                {
                    classFullName += "," + data.GenericParameters[i];
                }
                classFullName += ">";
            }

            if (!classGlobalName.Contains(".") && data.classNameSpace != "<global namespace>")
            {
                classGlobalName = "global::" + data.classNameSpace + "." + data.classFullName;
            }
            
            var derivedBaseType =
                data.isUnion || data.generatorType is GeneratorType.CircleReference or GeneratorType.VersionTolerant
                    ? $"LuminPackParser<{classGlobalName}>" 
                    : $"LuminData<{classGlobalName}>";
            
            sb.AppendLine("    [global::LuminPack.Attribute.Preserve]");
            sb.AppendLine("    [global::LuminPack.Attribute.LuminPackParser]");
            sb.AppendLine($"    public sealed class {classFullName} : {derivedBaseType}");
            
            foreach (var constraint in _dataInfo.GenericConstraints)
            {
                
                if (constraint.IsUnmanaged is false && 
                    constraint.IsClass is false && 
                    constraint.IsStruct is false &&
                    constraint.IsNotNull is false &&
                    constraint.HasDefault is false &&
                    constraint.HasNewConstructor is false &&
                    constraint.Constraints.Count is 0) continue;
                sb.Append("        ");
                sb.Append("where ");
                sb.Append(constraint.ParameterName);
                sb.Append(" : ");

                var constraints = new List<string>();

                // 特殊约束
                if (constraint.IsUnmanaged) constraints.Add("unmanaged");
                if (constraint.IsClass) constraints.Add("class");
                if (constraint.IsStruct) constraints.Add("struct");
                if (constraint.IsNotNull) constraints.Add("notnull");
                if (constraint.HasNewConstructor) constraints.Add("new()");
                if (constraint.HasDefault) constraints.Add("default");

                // 类型约束（如 IComparable）
                constraints.AddRange(constraint.Constraints);

                sb.Append(string.Join(", ", constraints));
                
                sb.AppendLine();
            }
            
            
            sb.AppendLine("    {");
            // sb.AppendLine(metaInfo.IsNet8 
            //     ? $"        public static bool num = true;" 
            //     : $"        public static bool num = false;");

            #region Union, VersionTolerant And CircleReference

            if (data.isUnion)
            {
                LuminPackUnionCodeGenerator.UnionCodeGenerator(sb, data, metaInfo);
                
                return sb.ToString();
            }

            switch (data.generatorType)
            {
                case GeneratorType.Object: break;
                case GeneratorType.VersionTolerant: 
                    LuminPackVersionTolerantCodeGenerator.VersionTolerantCodeGenerator(sb, data, metaInfo); return sb.ToString();
                case GeneratorType.CircleReference:
                    LuminPackCircleReferenceCodeGenerator.CircleReferenceCodeGenerator(sb, data, metaInfo); return sb.ToString();
                case GeneratorType.NonGenerator: return string.Empty;
            }
            

            #endregion
            
            // 静态构造函数注册
            sb.AppendLine($"        static {parserName}()");
            sb.AppendLine("        {");
            sb.AppendLine($"            LuminPackParseProvider.Register(new {classFullName}());");
            sb.AppendLine($"            LuminPackParseProvider.RegisterParsers(new ArrayParser<{classGlobalName}>());");
            sb.AppendLine("        }");
            sb.AppendLine();
            
            
            
            sb.AppendLine($"        private {parserName}(){{}}");
            sb.AppendLine();
            
            sb.AppendLine("        [global::LuminPack.Attribute.Preserve]");
            sb.AppendLine($"        public override void RegisterParser()");
            sb.AppendLine("        {");
            sb.AppendLine($"            LuminPackParseProvider.RegisterDataHandler<{classGlobalName}>(() => new {classFullName}());");
            sb.AppendLine($"            LuminPackParseProvider.RegisterAsyncHandler<{classGlobalName}>(() => new {classFullName}());");
            sb.AppendLine("        }");
            sb.AppendLine();
            
            // Serialize实现
            sb.AppendLine("        [global::LuminPack.Attribute.Preserve]");
            sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            if (data.enableBurst)
                sb.AppendLine("        [BurstCompile]");
            sb.AppendLine("        public override byte[] Serialize()");
            sb.AppendLine("        {");
            
            if (!_dataInfo.isValueType) 
                sb.AppendLine("            if (_dataRef is null) return Array.Empty<byte>();");

            //全unmanaged类型，直接Calculate优化性能，减少copy性能消耗
            if (isAllUnmanagedType)
            {
                sb.AppendLine("            var totalLength = 0;");
                sb.AppendLine("            var evaluator = new LuminPackEvaluator(ref totalLength);");
                sb.AppendLine();
                sb.AppendLine("            CalculateOffset(ref evaluator, ref _dataRef);");
                sb.AppendLine();
                sb.AppendLine("            var buffer = LuminPackMarshal.AllocateUninitializedArray<byte>(evaluator.Value);");
                sb.AppendLine("            var span = new Span<byte>(buffer);");
                sb.AppendLine("            var writer = new LuminPackWriter(ref span);");
                sb.AppendLine();
                sb.AppendLine("            Serialize(ref writer, ref _dataRef);");
                sb.AppendLine("            return buffer;");
                sb.AppendLine("        }");
                sb.AppendLine();
            }
            else
            {
                sb.AppendLine();
                sb.AppendLine("            var writerBuffer = ReusableLinkedArrayBufferWriterPool.Rent();");
                sb.AppendLine("            try");
                sb.AppendLine("            {");
                sb.AppendLine("                var writer = new LuminPackWriter(writerBuffer);");
                sb.AppendLine();
                sb.AppendLine("                Serialize(ref writer, ref _dataRef);");
                sb.AppendLine();
                sb.AppendLine("                var buffer = LuminPackMarshal.AllocateUninitializedArray<byte>(writer.CurrentIndex);");
                sb.AppendLine("                writer.GetSpan().CopyTo(buffer.AsSpan());");
                sb.AppendLine("                return buffer;");
                sb.AppendLine("            }");
                sb.AppendLine("            finally");
                sb.AppendLine("            {");
                sb.AppendLine("                ReusableLinkedArrayBufferWriterPool.Return(writerBuffer);");
                sb.AppendLine("            }");
                sb.AppendLine("        }");
                sb.AppendLine();
            }
            
            
            sb.AppendLine("        [global::LuminPack.Attribute.Preserve]");
            sb.AppendLine(metaInfo.IsNet8 
                ? $"        public override void Serialize(ref LuminPackWriter writer, scoped ref {classGlobalName}{paraNullable} value)"
                : $"        public override void Serialize(ref LuminPackWriter writer, ref {classGlobalName}{paraNullable} value)");
            sb.AppendLine("        {");
            
            foreach (var item in data.callBackMethods.Where(x => x.Item2 is SerializeCallBackType.OnSerializing))
            {
                sb.AppendLine(item.Item3
                    ? $"            {classGlobalName}.{item.Item1}();"
                    : $"            value?.{item.Item1}();");
            }
            sb.AppendLine();
            
            if (!_dataInfo.isValueType)
            {
                sb.AppendLine("            if (value is null)");
                sb.AppendLine("            {");
                sb.AppendLine("                writer.WriteNullObjectHeader();");
                sb.AppendLine("                writer.Advance(1);");
                sb.AppendLine("                return;");
                sb.AppendLine("            }");
            }
            
            sb.AppendLine();
            if (_dataInfo.fields.Count(x => x.IsPrivate) > 0)
            {
                sb.AppendLine($"            ref var local = ref LuminPackMarshal.As<{classGlobalName}, Local{data.classFullName}>(ref value);");
            }
            sb.AppendLine("            ref int offset = ref writer.GetCurrentSpanOffset();");
            sb.AppendLine($"            writer.WriteObjectHeader(ref offset, {data.fields.Count});");
            sb.AppendLine($"            writer.Advance(1);");
            //sb.AppendLine("            var span = writer.GetSpan();");
            sb.AppendLine();

            for (var i = 0; i < data.fields.Count; i++)
            {
                var access = data.fields[i].IsPrivate ? "local" : "value";
                
                if (data.fields[i].FieldType is LuminDataType.Reference && data.fields[i].Type is not LuminFiledType.Other)
                {
                    sb.AppendLine($"            if ({access}.{data.fields[i].Name} != null)");
                    sb.AppendLine("            {");
                    GenerateSerializeCode(sb, data.fields[i], $"{access}." + data.fields[i].Name, "span", "offset", 4, 0);
                    if (data.fields[i].Type is not LuminFiledType.Class)
                    {
                        if (data.fields[i].Type is LuminFiledType.Array or LuminFiledType.List)
                            //sb.AppendLine($"                offset = {GetFieldLength(data.fields[i], 0, pattern: "writer")};");
                            sb.AppendLine($"                writer.FlushCurrentIndex({GetFieldLength(data.fields[i], 0, pattern: "writer")});");
                        else 
                            //sb.AppendLine($"                offset += {GetFieldLength(data.fields[i], 0, pattern: "writer")};");
                            sb.AppendLine($"                writer.Advance({GetFieldLength(data.fields[i], 0, pattern: "writer")});");
                    }
                        
                    sb.AppendLine("            }");

                    switch (data.fields[i].Type)
                    {
                        case LuminFiledType.Array or LuminFiledType.List:
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            sb.AppendLine("                writer.WriteNullCollectionHeader(ref offset);");
                            
                            sb.AppendLine("                offset += 4;");
                            sb.AppendLine("            }"); break;
                        case LuminFiledType.String:
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            sb.AppendLine("                writer.WriteNullStringHeader(ref offset);");
                            
                            sb.AppendLine("                offset += writer.StringRecordLength();");
                            sb.AppendLine("            }"); break;
                        default:
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            sb.AppendLine("                writer.WriteNullObjectHeader(ref offset);");
                            
                            sb.AppendLine("                offset += 1;");
                            sb.AppendLine("            }"); break;
                    }
                    
                }
                else
                {
                    #region 连续值类型字段优化

                    if (IsUnmanagedFiledType(data.fields[i].Type))
                    {
                        var num = FindNextUnmanagedType(data, i);

                        if (num != i)
                        {
                            if (num - i >= 14)
                            {
                                num = i + 14;
                            }
                            
                            sb.Append("            writer.Advance(writer.WriteUnmanaged(ref offset");
                            for (var j = i; j <= num; j++)
                            {
                                
                                sb.Append($", {access}.{data.fields[j].Name}");
                            }
                            sb.Append("));");
                            sb.AppendLine();
                            i = num;
                            continue;
                            
                        }
                    }
                    
                    #endregion
                    
                    
                    GenerateSerializeCode(sb, data.fields[i], $"{access}." + data.fields[i].Name, "span", "offset", 3, 0);
                    
                    
                    if (data.fields[i].Type is not LuminFiledType.Struct) 
                        //sb.AppendLine($"            offset += {GetFieldLength(data.fields[i], 0, pattern: "writer")};");
                        sb.AppendLine($"            writer.Advance({GetFieldLength(data.fields[i], 0, pattern: "writer")});");
                    
                }
                    
            }
            
            foreach (var item in data.callBackMethods.Where(x => x.Item2 is SerializeCallBackType.OnSerialized))
            {
                sb.AppendLine(item.Item3
                    ? $"            {classGlobalName}.{item.Item1}();"
                    : $"            value?.{item.Item1}();");
            }
            sb.AppendLine();
            sb.AppendLine("        }");

            sb.AppendLine();
            
            // Deserialize实现
            sb.AppendLine("        [global::LuminPack.Attribute.Preserve]");
            sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        public override {classGlobalName}{paraNullable} Deserialize()");
            sb.AppendLine("        {");
            //sb.AppendLine($"            var data = new {data.classFullName}();");
            
            sb.AppendLine("            return Deserialize(default)!;");
            //sb.AppendLine("            return data!;");
            sb.AppendLine("        }");
            
            
            sb.AppendLine();

            // Deserialize实现
            sb.AppendLine("        [global::LuminPack.Attribute.Preserve]");
            sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            if (data.enableBurst)
                sb.AppendLine("        [BurstCompile]");
            sb.AppendLine($"        public override {classGlobalName}{paraNullable} Deserialize({classGlobalName}{paraNullable} result)");
            sb.AppendLine("        {");
            sb.AppendLine("            var span = new Span<byte>(_data);");
            sb.AppendLine("            var reader = new LuminPackReader(ref span);");
            sb.AppendLine();
            sb.AppendLine($"            Deserialize(ref reader, ref result);");
            sb.AppendLine();
            sb.AppendLine("            return result;");
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine("        [global::LuminPack.Attribute.Preserve]");
            sb.AppendLine(metaInfo.IsNet8 
                ? $"        public override void Deserialize(ref LuminPackReader reader, scoped ref {classGlobalName}{paraNullable} value)"
                : $"        public override void Deserialize(ref LuminPackReader reader, ref {classGlobalName}{paraNullable} value)");
            sb.AppendLine("        {");
            
            sb.AppendLine();
            foreach (var item in data.callBackMethods.Where(x => x.Item2 is SerializeCallBackType.OnDeserializing))
            {
                sb.AppendLine(item.Item3
                    ? $"            {classGlobalName}.{item.Item1}();"
                    : $"            value?.{item.Item1}();");
            }
            
            //if (!_dataInfo.isValueType) 
                //sb.AppendLine($"            if (value is null) value = new {data.classFullName}();");
            sb.AppendLine();
            sb.AppendLine("            ref int offset = ref reader.GetCurrentSpanOffset();");
            //sb.AppendLine("            var span = reader.GetSpan();");
            sb.AppendLine($"            var local = new Local{data.classFullName}();");
            if (_dataInfo.fields.Count(x => x.IsPrivate) > 0)
            {
                //sb.AppendLine($"            ref var local = ref LuminPackMarshal.As<{data.classFullName}, Local{data.classFullName}>(ref value);");
            }

            sb.AppendLine();
            sb.AppendLine($"            if (reader.PeekIsNullObject(ref offset))");
            sb.AppendLine($"            {{");
            sb.AppendLine($"                offset += 1;");
            sb.AppendLine($"                return;");
            sb.AppendLine($"            }}");
            sb.AppendLine($"            offset += 1;");
            sb.AppendLine();
            for (var i = 0; i < data.fields.Count; i++)
            {
                var access = "local";
                
                if (data.fields[i].FieldType is LuminDataType.Reference && data.fields[i].Type is not LuminFiledType.Other)
                {
                    switch (data.fields[i].Type)
                    {
                        case LuminFiledType.Array or LuminFiledType.List:
                            sb.AppendLine("            if (reader.PeekIsNullCollection(ref offset))");
                            sb.AppendLine("            {");
                            sb.AppendLine("                offset += 4;");
                            sb.AppendLine("            }");
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            GenerateDeserializeCode(sb, data.fields[i], access, "span", "offset", 4, 0);
                    
                            if(data.fields[i].Type is not LuminFiledType.String)  
                                sb.AppendLine($"                offset = {GetFieldLength(data.fields[i], 0, pattern: "reader")};");
                            sb.AppendLine("            }");
                            break;
                        case LuminFiledType.String:
                            sb.AppendLine("            if (reader.PeekIsNullString(ref offset))");
                            sb.AppendLine("            {");
                            sb.AppendLine("                offset += reader.StringRecordLength();");
                            sb.AppendLine("            }");
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            GenerateDeserializeCode(sb, data.fields[i], access, "span", "offset", 4, 0);
                    
                            if(data.fields[i].Type is not LuminFiledType.String) 
                                sb.AppendLine($"                offset += {GetFieldLength(data.fields[i], 0, pattern: "reader")};");
                            sb.AppendLine("            }");
                            break;
                        default:
                            sb.AppendLine("            if (reader.PeekIsNullObject(ref offset))");
                            sb.AppendLine("            {");
                            sb.AppendLine("                offset += 1;");
                            sb.AppendLine("            }");
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            GenerateDeserializeCode(sb, data.fields[i], access, "span", "offset", 4, 0);
                            
                            if(data.fields[i].Type is not LuminFiledType.String and not LuminFiledType.Class) 
                                sb.AppendLine($"                offset += {GetFieldLength(data.fields[i], 0, pattern: "reader")};");
                            sb.AppendLine("            }");
                            break;
                    }
                }
                else
                {
                    
                    #region 连续值类型字段优化

                    if (IsUnmanagedFiledType(data.fields[i].Type))
                    {
                        var num = FindNextUnmanagedType(data, i);

                        if (num != i)
                        {
                            if (num - i >= 14)
                            {
                                num = i + 14;
                            }
                            
                            sb.Append("            offset += reader.ReadUnmanaged(ref offset");
                            for (var j = i; j <= num; j++)
                            {
                                
                                sb.Append($", out {access}.{data.fields[j].Name}");
                            }
                            sb.Append(");");
                            sb.AppendLine();
                            i = num;
                            continue;
                            
                        }
                    }
                    
                    #endregion
                    
                    GenerateDeserializeCode(sb, data.fields[i], access, "span", "offset", 3, 0);
                    
                    if (data.fields[i].Type is LuminFiledType.String or LuminFiledType.Struct) continue;
                    
                    
                    sb.AppendLine($"            offset += {GetFieldLength(data.fields[i], 0, pattern: "reader")};");
                }
                
            }
            sb.AppendLine($"            value = LuminPackMarshal.As<Local{data.classFullName}, {classGlobalName}>(ref local);");
            //sb.AppendLine("            reader.FlushCurrentIndex(offset);");
            
            sb.AppendLine();
            foreach (var item in data.callBackMethods.Where(x => x.Item2 is SerializeCallBackType.OnDeserialized))
            {
                sb.AppendLine(item.Item3
                    ? $"            {classGlobalName}.{item.Item1}();"
                    : $"            value?.{item.Item1}();");
            }
            sb.AppendLine();
            
            sb.AppendLine("        }");
            
            sb.AppendLine();

            sb.AppendLine("        [global::LuminPack.Attribute.Preserve]");
            sb.AppendLine(metaInfo.IsNet8 
                ? $"        public override void CalculateOffset(ref LuminPackEvaluator evaluator, scoped ref {classGlobalName}{paraNullable} value)"
                : $"        public override void CalculateOffset(ref LuminPackEvaluator evaluator, ref {classGlobalName}{paraNullable} value)");
            sb.AppendLine("        {");
            sb.AppendLine("            // 计算总字节长度");
            if (!_dataInfo.isValueType)
            {
                sb.AppendLine("            if (value is null)");
                sb.AppendLine("            {");
                sb.AppendLine("                evaluator += 1;");
                sb.AppendLine("                return;");
                sb.AppendLine("            }");
            }
                
            sb.AppendLine();
            if (_dataInfo.fields.Count(x => x.IsPrivate) > 0)
            {
                sb.AppendLine($"            ref var local = ref LuminPackMarshal.As<{classGlobalName}, Local{data.classFullName}>(ref value);");
            }
            sb.AppendLine("            int totalLength = 1;");
            sb.AppendLine();
            for (var i = 0; i < data.fields.Count; i++)
            {
                var access = data.fields[i].IsPrivate ? "local" : "value";
                
                if (data.fields[i].FieldType is LuminDataType.Reference && data.fields[i].Type is not LuminFiledType.Other)
                {
                    if (data.fields[i].Type is LuminFiledType.String)
                    {
                        sb.AppendLine($"            var {data.fields[i].Name}Length = 0;");
                        sb.AppendLine($"            if ({access}.{data.fields[i].Name} != null)");
                        sb.AppendLine("            {");
                        sb.AppendLine($"                var {data.fields[i].Name}TempValue = {access}.{data.fields[i].Name};");
                        sb.AppendLine($"                totalLength += evaluator.GetStringLength(ref {data.fields[i].Name}TempValue);");
                        sb.AppendLine("            }");
                        sb.AppendLine("            else");
                        sb.AppendLine("            {");
                        sb.AppendLine($"                totalLength += evaluator.StringRecordLength();");
                        sb.AppendLine("            }");
                        
                        continue;
                    }
                    sb.AppendLine($"            if ({access}.{data.fields[i].Name} != null)");
                    sb.AppendLine("            {");
                    GenerateSerializeLengthCode(sb, data.fields[i], $"{access}." + data.fields[i].Name, 4, 0);
                    sb.AppendLine("            }");
                    switch (data.fields[i].Type)
                    {
                        case LuminFiledType.Array or LuminFiledType.List:
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            sb.AppendLine($"                totalLength += 4;");
                            sb.AppendLine("            }"); break;
                        default:
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            sb.AppendLine($"                totalLength += 1;");
                            sb.AppendLine("            }"); break;
                    }
                }
                else
                {
                    
                    #region 连续值类型字段优化

                    if (IsUnmanagedFiledType(data.fields[i].Type))
                    {
                        var num = FindNextUnmanagedType(data, i);

                        if (num != i)
                        {
                            
                            int sum = 0;
                            for (var j = i; j <= num; j++)
                            {
                                int.TryParse(GetFixedFieldLength(data.fields[j]), out var result);
                                sum += result;
                            }
                            sb.Append($"            totalLength += {sum};");
                            sb.AppendLine();
                            i = num;
                            continue;
                            
                        }
                    }
                    
                    #endregion
                    
                    GenerateSerializeLengthCode(sb, data.fields[i], $"{access}." + data.fields[i].Name, 3, 0);
                }

                
            }
            sb.AppendLine();
            sb.AppendLine("            evaluator += totalLength;");
            sb.AppendLine("        }");
            
            sb.AppendLine();

            // SerializeAsync实现
            sb.AppendLine("        [global::LuminPack.Attribute.Preserve]");
            sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("        public override async Task<byte[]> SerializeAsync()");
            sb.AppendLine("        {");
            sb.AppendLine("            return await Task.Run(Serialize);");
            sb.AppendLine("        }");
            sb.AppendLine();

            // DeserializeAsync实现
            sb.AppendLine("        [global::LuminPack.Attribute.Preserve]");
            sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        public override async Task<{classGlobalName}{paraNullable}> DeserializeAsync()");
            sb.AppendLine("        {");
            //sb.AppendLine($"            var data = new {data.classFullName}();");
            sb.AppendLine("            return await Task.Run(() => Deserialize(default));");
            sb.AppendLine("        }");
            
            sb.AppendLine();
            
            sb.AppendLine("        [global::LuminPack.Attribute.Preserve]");
            sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        public override async Task<{classGlobalName}{paraNullable}> DeserializeAsync({classGlobalName}{paraNullable} result)");
            sb.AppendLine("        {");
            sb.AppendLine("            return await Task.Run(() => Deserialize(result));");
            sb.AppendLine("        }");

            sb.AppendLine();
            switch (data.structLayout)
            {
                case StructLayout.Explicit : sb.AppendLine("        [global::System.Runtime.InteropServices.StructLayout(LayoutKind.Explicit)]"); break;
                case StructLayout.Auto : sb.AppendLine("        [global::System.Runtime.InteropServices.StructLayout(LayoutKind.Auto)]"); break;
                case StructLayout.Sequential : sb.AppendLine("        [global::System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]"); break;
                case StructLayout.Default : break;
            }
            sb.AppendLine("        [global::LuminPack.Attribute.Preserve]");
            sb.AppendLine(_dataInfo.isValueType 
                ? $"        private struct Local{_dataInfo.classFullName}" 
                : $"        private sealed class Local{_dataInfo.classFullName}");
            sb.AppendLine("        {");
            foreach (var field in _dataInfo.localFields)
            {
                if (data.structLayout is StructLayout.Explicit)
                    sb.AppendLine($"            [global::System.Runtime.InteropServices.FieldOffset({field.filedOffset})]");
                var nullable = IsUnmanagedFiledType(field.TypeName) || field.IsValue ? string.Empty : "?";
                sb.AppendLine($"            internal {field.TypeName}{nullable} {field.Name};");
            }
            
            sb.AppendLine("        }");
            
            sb.AppendLine();

            foreach (var filed in data.fields.Where(x => x.ClassFields.Count > 0))
            {
                GeneratorUnsafeAccessorMethod(sb, filed, filed.ClassFields);
            }
            

            // foreach (var field in _dataInfo.fields)
            // {
            //     if (field.Type is LuminFiledType.Struct or LuminFiledType.Class)
            //     {
            //         sb.AppendLine(field.Type is LuminFiledType.Struct 
            //             ? $"        private struct Local{field.ClassName}" 
            //             : $"        private sealed class Local{field.ClassName}");
            //         sb.AppendLine("        {");
            //         foreach (var localField in field.localFields)
            //         {
            //             var nullable = IsUnmanagedFiledType(localField.TypeName) ? string.Empty : "?";
            //             sb.AppendLine($"            internal {localField.TypeName}{nullable} {localField.Name};");
            //         }
            //
            //         sb.AppendLine("        }");
            //         
            //         sb.AppendLine();
            //     }
            //     
            //     
            // }
            
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static void GenerateSerializeLengthCode(StringBuilder sb, LuminDataField field, string fieldPath,
            int indent, int depth, string multList = "_")
        {
            string indentStr = new string(' ', indent * 4);
            string depthSuffix = $"{multList}{depth}";

            switch (field.Type)
            {
                case LuminFiledType.Byte or LuminFiledType.Bool:
                    sb.AppendLine($"{indentStr}totalLength += 1;");
                    break;
                case LuminFiledType.Short or LuminFiledType.UShort:
                    sb.AppendLine($"{indentStr}totalLength += 2;");
                    break;
                case LuminFiledType.Int or LuminFiledType.Float or LuminFiledType.UInt:
                    sb.AppendLine($"{indentStr}totalLength += 4;");
                    break;
                case LuminFiledType.Long or  LuminFiledType.Double or LuminFiledType.ULong:
                    sb.AppendLine($"{indentStr}totalLength += 8;");
                    break;
                case LuminFiledType.String:
                    //sb.AppendLine($"{indentStr}var {field.Name}Length = System.Text.Encoding.UTF8.GetByteCount({fieldPath});");
                    sb.AppendLine($"{indentStr}var {field.Name}{depthSuffix}TempValue = {fieldPath};");
                    sb.AppendLine($"{indentStr}totalLength += evaluator.GetStringLength(ref {field.Name}{depthSuffix}TempValue);");
                    break;
                case LuminFiledType.List:
                    var elementType = ConvertGenericsToFieldType(field.GenericType[0]);
                    bool isElementList = elementType == LuminFiledType.List;
    
                    if (!isElementList && IsFixedLengthType(elementType))
                    {
                        string elementLength = GetFixedFieldLength(new LuminDataField { Type = elementType });
                        if (depth > 0)
                            sb.AppendLine($"{indentStr}if ({fieldPath} == null) continue;");
                        sb.AppendLine($"{indentStr}totalLength += 4 + {fieldPath}.Count * {elementLength};");
                    }
                    else if (elementType is LuminFiledType.Class or LuminFiledType.Struct)
                    {
                        
                        sb.AppendLine($"{indentStr}totalLength += 4; // 列表长度前缀");
                        if (depth > 0) 
                            sb.AppendLine($"{indentStr}if ({fieldPath} == null) continue;");
                        
                        if (elementType is LuminFiledType.Struct)
                        {
                            sb.AppendLine($"{indentStr}if (!evaluator.IsReferenceOrContainsReferences<{field.ClassName}>())");
                            sb.AppendLine($"{indentStr}    totalLength += Unsafe.SizeOf<{field.ClassName}>() * {fieldPath}.Count;");
                            sb.AppendLine($"{indentStr}else");
                        }
                        
                        sb.AppendLine($"{indentStr}for (int i{depthSuffix} = 0; i{depthSuffix} < {fieldPath}.Count; i{depthSuffix}++)"); // 改为for循环
                        sb.AppendLine($"{indentStr}{{");
                        sb.AppendLine($"{indentStr}    var element = {fieldPath}[i{depthSuffix}];"); // 通过索引访问
                        
                        // if (elementType is LuminFiledType.Class) 
                        //     sb.AppendLine($"{indentStr}    if (element == null) continue;");
                        sb.AppendLine($"{indentStr}    totalLength += 1;");
                        
                        for (int i = 0; i < field.ClassFields.Count; i++)
                        {
                            var subField = field.ClassFields[i];
                            
                            if (subField.FieldType is LuminDataType.Reference)
                            {
                                if (subField.IsPrivate)
                                    sb.AppendLine($"{indentStr}    if (Get{field.Name}{subField.Name}(element) != null)");
                                else 
                                    sb.AppendLine($"{indentStr}    if (element.{subField.Name} != null)");
                                
                                sb.AppendLine($"{indentStr}    {{");
                                if (subField.IsPrivate)
                                {
                                    GenerateSerializeLengthCode(sb, subField, $"Get{field.Name}{subField.Name}(element)", indent + 2, depth + 1);
                                }
                                else 
                                    GenerateSerializeLengthCode(sb, subField, "element." + subField.Name, indent + 2, depth + 1);
                                
                                sb.AppendLine($"{indentStr}    }}");
                                switch (subField.Type)
                                {
                                    case LuminFiledType.List or LuminFiledType.Array:
                                        sb.AppendLine($"{indentStr}    else");
                                        sb.AppendLine($"{indentStr}    {{");
                                        sb.AppendLine($"{indentStr}        totalLength += 4;");
                                        sb.AppendLine($"{indentStr}    }}"); break;
                                    case LuminFiledType.String:
                                        sb.AppendLine($"{indentStr}    else");
                                        sb.AppendLine($"{indentStr}    {{");
                                        sb.AppendLine($"{indentStr}        totalLength += evaluator.StringRecordLength();");
                                        sb.AppendLine($"{indentStr}    }}"); break;
                                    default:
                                        sb.AppendLine($"{indentStr}    else");
                                        sb.AppendLine($"{indentStr}    {{");
                                        sb.AppendLine($"{indentStr}        totalLength += 1;");
                                        sb.AppendLine($"{indentStr}    }}"); break;
                                }
                                
                            }
                            else
                            {
                                
                                #region 连续值类型字段优化

                                if (IsUnmanagedFiledType(subField.Type))
                                {
                                    var num = FindNextUnmanagedType(field.ClassFields, i);

                                    if (num != i)
                                    {
                                        int sum = 0;
                                        for (var j = i; j <= num; j++)
                                        {
                                            int.TryParse(GetFixedFieldLength(field.ClassFields[j]), out var result);
                                            sum += result;
                                        }
                                        sb.Append($"{indentStr}    totalLength += {sum};");
                                        sb.AppendLine();
                                        i = num;
                                        continue;
                            
                                    }
                                }
                    
                                #endregion
                                
                                GenerateSerializeLengthCode(sb, subField, "element." + subField.Name, indent + 1, depth + 1);
                            }
                            
                        }
                        sb.AppendLine($"{indentStr}}}");
                    }
                    else
                    {
                        // 处理嵌套列表或可变长度元素
                        sb.AppendLine($"{indentStr}totalLength += 4;");
                        if (depth > 0) 
                            sb.AppendLine($"{indentStr}if ({fieldPath} == null) continue;");
                        sb.AppendLine(field.FixLength is int.MaxValue 
                            ? $"{indentStr}for (int i{depthSuffix} = 0; i{depthSuffix} < {fieldPath}.Count; i{depthSuffix}++)"
                            : $"{indentStr}for (int i{depthSuffix} = 0; i{depthSuffix} < {field.FixLength}; i{depthSuffix}++)");
                        
                        sb.AppendLine($"{indentStr}{{");
                        var elementField = new LuminDataField
                        {
                            Type = elementType, 
                            FieldType = field.FieldType,
                            GenericType = field.GenericType.Skip(1).ToList(),
                            ClassFields = field.ClassFields,
                            ClassName = field.ClassName,
                            ClassGenericType = field.ClassGenericType
                        };
                        
                        if (elementType is LuminFiledType.String)
                        {
                            sb.AppendLine($"{indentStr}    if ({fieldPath}[i{depthSuffix}] == null)");
                            sb.AppendLine($"{indentStr}    {{");
                            sb.AppendLine($"{indentStr}        totalLength += evaluator.StringRecordLength();");
                            sb.AppendLine($"{indentStr}        continue;");
                            sb.AppendLine($"{indentStr}    }}");
                        }
                        
                        GenerateSerializeLengthCode(sb, elementField, $"{fieldPath}[i{depthSuffix}]", indent + 1, depth + 1);
                        sb.AppendLine($"{indentStr}}}");
                    }
                    break;
                case LuminFiledType.Array:
                    var arrayType = ConvertGenericsToFieldType(field.GenericType[0]);
                    bool isElementArray = arrayType == LuminFiledType.Array;
    
                    if (!isElementArray && IsFixedLengthType(arrayType))
                    {
                        string elementLength = GetFixedFieldLength(new LuminDataField { Type = arrayType });
                        if (depth > 0) 
                            sb.AppendLine($"{indentStr}if ({fieldPath} == null) continue;");
                        sb.AppendLine($"{indentStr}totalLength += 4 + {fieldPath}.Length * {elementLength};");
                    }
                    else if (arrayType is LuminFiledType.Class or LuminFiledType.Struct)
                    {
                        sb.AppendLine($"{indentStr}totalLength += 4; // 列表长度前缀");
                        if (depth > 0 && arrayType is LuminFiledType.Class) 
                            sb.AppendLine($"{indentStr}if ({fieldPath} == null) continue;");
                        
                        if (arrayType is LuminFiledType.Struct)
                        {
                            sb.AppendLine($"{indentStr}if (!evaluator.IsReferenceOrContainsReferences<{field.ClassName}>())");
                            sb.AppendLine($"{indentStr}    totalLength += Unsafe.SizeOf<{field.ClassName}>() * {fieldPath}.Length;");
                            sb.AppendLine($"{indentStr}else");
                        }
                        
                        sb.AppendLine($"{indentStr}for (int i{depthSuffix} = 0; i{depthSuffix} < {fieldPath}.Length; i{depthSuffix}++)"); // 改为for循环
                        sb.AppendLine($"{indentStr}{{");
                        sb.AppendLine($"{indentStr}    totalLength += 1;");
                        
                        for (int i = 0; i < field.ClassFields.Count; i++)
                        {
                            var subField  = field.ClassFields[i];
                            
                            if (subField.FieldType is LuminDataType.Reference)
                            {
                                if (subField.IsPrivate)
                                    sb.AppendLine($"{indentStr}    if (Get{field.Name}{subField.Name}({fieldPath}[i{depthSuffix}]) != null)");
                                else 
                                    sb.AppendLine($"{indentStr}    if ({fieldPath}[i{depthSuffix}].{subField.Name} != null)");
                                
                                sb.AppendLine($"{indentStr}    {{");
                                if (subField.IsPrivate)
                                {
                                    GenerateSerializeLengthCode(sb, subField, $"Get{field.Name}{subField.Name}({fieldPath}[i{depthSuffix}])", indent + 2, depth + 1);
                                }
                                else 
                                    GenerateSerializeLengthCode(sb, subField, $"{fieldPath}[i{depthSuffix}]." + subField.Name, indent + 2, depth + 1);
                                
                                sb.AppendLine($"{indentStr}    }}");
                                switch (subField.Type)
                                {
                                    case LuminFiledType.List or LuminFiledType.Array:
                                        sb.AppendLine($"{indentStr}    else");
                                        sb.AppendLine($"{indentStr}    {{");
                                        sb.AppendLine($"{indentStr}        totalLength += 4;");
                                        sb.AppendLine($"{indentStr}    }}"); break;
                                    case LuminFiledType.String:
                                        sb.AppendLine($"{indentStr}    else");
                                        sb.AppendLine($"{indentStr}    {{");
                                        sb.AppendLine($"{indentStr}        totalLength += evaluator.StringRecordLength();");
                                        sb.AppendLine($"{indentStr}    }}"); break;
                                    default:
                                        sb.AppendLine($"{indentStr}    else");
                                        sb.AppendLine($"{indentStr}    {{");
                                        sb.AppendLine($"{indentStr}        totalLength += 1;");
                                        sb.AppendLine($"{indentStr}    }}"); break;
                                }
                            }
                            else
                            {
                                #region 连续值类型字段优化

                                if (IsUnmanagedFiledType(subField.Type))
                                {
                                    var num = FindNextUnmanagedType(field.ClassFields, i);

                                    if (num != i)
                                    {
                                        int sum = 0;
                                        for (var j = i; j <= num; j++)
                                        {
                                            int.TryParse(GetFixedFieldLength(field.ClassFields[j]), out var result);
                                            sum += result;
                                        }
                                        sb.Append($"{indentStr}    totalLength += {sum};");
                                        sb.AppendLine();
                                        i = num;
                                        continue;
                            
                                    }
                                }
                    
                                #endregion
                                
                                GenerateSerializeLengthCode(sb, subField, $"{fieldPath}[i{depthSuffix}]." + subField.Name, indent + 1, depth + 1);
                            }
                            
                        }
                        sb.AppendLine($"{indentStr}}}");
                    }
                    else
                    {
                        // 处理嵌套列表或可变长度元素
                        sb.AppendLine($"{indentStr}totalLength += 4;");
                        if (depth > 0) 
                            sb.AppendLine($"{indentStr}if ({fieldPath} == null) continue;");
                        sb.AppendLine(field.FixLength is int.MaxValue 
                            ? $"{indentStr}for (int i{depthSuffix} = 0; i{depthSuffix} < {fieldPath}.Length; i{depthSuffix}++)"
                            : $"{indentStr}for (int i{depthSuffix} = 0; i{depthSuffix} < {field.FixLength}; i{depthSuffix}++)");
                            
                        sb.AppendLine($"{indentStr}{{");
                        var elementField = new LuminDataField
                        {
                            Type = arrayType, 
                            FieldType = field.FieldType,
                            GenericType = field.GenericType.Skip(1).ToList(),
                            ClassFields = field.ClassFields,
                            ClassName = field.ClassName,
                            ClassGenericType = field.ClassGenericType
                        };
                        
                        if (arrayType is LuminFiledType.String)
                        {
                            sb.AppendLine($"{indentStr}    if ({fieldPath}[i{depthSuffix}] == null)");
                            sb.AppendLine($"{indentStr}    {{");
                            sb.AppendLine($"{indentStr}        totalLength += evaluator.StringRecordLength();");
                            sb.AppendLine($"{indentStr}        continue;");
                            sb.AppendLine($"{indentStr}    }}");
                        }
                        
                        
                        GenerateSerializeLengthCode(sb, elementField, $"{fieldPath}[i{depthSuffix}]", indent + 1, depth + 1);
                        sb.AppendLine($"{indentStr}}}");
                    }
                    break;
                case LuminFiledType.Class:
                case LuminFiledType.Struct:
                    
                    sb.AppendLine($"{indentStr}// {field.ClassName}长度计算");
                    sb.AppendLine($"{indentStr}totalLength += 1;");
                    for (int i = 0; i < field.ClassFields.Count; i++)
                    {
                        var subField = field.ClassFields[i];
                        if (subField.FieldType is LuminDataType.Reference)
                        {
                            if (subField.IsPrivate)
                                sb.AppendLine($"{indentStr}if (Get{field.Name}{subField.Name}({fieldPath}) != null)");
                            else 
                                sb.AppendLine($"{indentStr}if ({fieldPath}.{subField.Name} != null)");
                            sb.AppendLine($"{indentStr}{{");
                            var classDepth = subField.Type is LuminFiledType.Array or LuminFiledType.List ? 0 : depth + 1;

                            if (subField.IsPrivate)
                            {
                                GenerateSerializeLengthCode(sb, subField, $"Get{field.Name}{subField.Name}({fieldPath})", indent + 1, classDepth, multList + "_");
                            }
                            else 
                                GenerateSerializeLengthCode(sb, subField, $"{fieldPath}.{subField.Name}", indent + 1, classDepth, multList + "_");
                            
                            sb.AppendLine($"{indentStr}}}");
                            switch (subField.Type)
                            {
                                case LuminFiledType.List or LuminFiledType.Array:
                                    sb.AppendLine($"{indentStr}else");
                                    sb.AppendLine($"{indentStr}{{");
                                    sb.AppendLine($"{indentStr}    totalLength += 4;");
                                    sb.AppendLine($"{indentStr}}}"); break;
                                case LuminFiledType.String:
                                    sb.AppendLine($"{indentStr}else");
                                    sb.AppendLine($"{indentStr}{{");
                                    sb.AppendLine($"{indentStr}    totalLength += evaluator.StringRecordLength();");
                                    sb.AppendLine($"{indentStr}}}"); break;
                                default:
                                    sb.AppendLine($"{indentStr}else");
                                    sb.AppendLine($"{indentStr}{{");
                                    sb.AppendLine($"{indentStr}    totalLength += 1;");
                                    sb.AppendLine($"{indentStr}}}"); break;
                            }
                        }
                        else
                        {
                            
                            #region 连续值类型字段优化

                            if (IsUnmanagedFiledType(subField.Type))
                            {
                                var num = FindNextUnmanagedType(field.ClassFields, i);

                                if (num != i)
                                {
                                    int sum = 0;
                                    for (var j = i; j <= num; j++)
                                    {
                                        int.TryParse(GetFixedFieldLength(field.ClassFields[j]), out var result);
                                        sum += result;
                                    }
                                    sb.Append($"{indentStr}totalLength += {sum};");
                                    sb.AppendLine();
                                    i = num;
                                    continue;
                            
                                }
                            }
                    
                            #endregion
                            
                            GenerateSerializeLengthCode(sb, subField, $"{fieldPath}.{subField.Name}", indent, depth + 1, multList + "_");
                        }
                        
                    }
                    break;
                case LuminFiledType.Enum:
                    sb.AppendLine($"{indentStr}totalLength += {GetEnumFieldLength(field.EnumType)};");
                    break;
                case LuminFiledType.Other:
                default:
                    sb.AppendLine($"{indentStr}evaluator.CalculateValue(in {fieldPath});"); break;
            }
        }


        private static void GenerateSerializeCode(StringBuilder sb, LuminDataField field, string fieldPath, string span, string offset, int indent, int depth, bool isMultClass = false)
        {
            string indentStr = new string(' ', indent * 4);
            string depthSuffix = $"_{depth}";

            switch (field.Type)
            {
                case LuminFiledType.Byte:
                    sb.AppendLine($"{indentStr}writer.GetSpanReference({offset}) = {fieldPath};");
                    if (isMultClass)
                        sb.AppendLine($"{indentStr}{offset} += 1;");
                    break;
                case LuminFiledType.Bool:
                    sb.AppendLine($"{indentStr}writer.WriteUnmanagedWithoutSizeReturn(ref {offset}, {fieldPath});");
                    if (isMultClass)
                        sb.AppendLine($"{indentStr}{offset} += 1;");
                    break;
                case LuminFiledType.Short or LuminFiledType.UShort:
                    sb.AppendLine($"{indentStr}writer.WriteUnmanagedWithoutSizeReturn(ref {offset}, {fieldPath});");
                    if (isMultClass)
                        sb.AppendLine($"{indentStr}{offset} += 2;");
                    break;
                case LuminFiledType.Int or LuminFiledType.UInt:
                case LuminFiledType.Float:
                    sb.AppendLine($"{indentStr}writer.WriteUnmanagedWithoutSizeReturn(ref {offset}, {fieldPath});");
                    if (isMultClass)
                        sb.AppendLine($"{indentStr}{offset} += 4;");
                    break;
                case LuminFiledType.Long or LuminFiledType.ULong:
                case LuminFiledType.Double:
                    sb.AppendLine($"{indentStr}writer.WriteUnmanagedWithoutSizeReturn(ref {offset}, {fieldPath});");
                    if (isMultClass)
                        sb.AppendLine($"{indentStr}{offset} += 8;");
                    break;
                case LuminFiledType.String:
                    //if (depth < 1) sb.AppendLine($"{indentStr}var {field.Name}Length = writer.GetStringLength({fieldPath});");
                    sb.AppendLine($"{indentStr}var {field.Name}Length = writer.WriteString(ref {offset}, {fieldPath});");
                    if (isMultClass)
                        sb.AppendLine($"{indentStr}{offset} += {field.Name}Length + writer.StringRecordLength();");
                    //sb.AppendLine($"{indentStr}System.Text.Encoding.UTF8.GetBytes({fieldPath}, {span}.Slice({offset}, {field.Name}Length));");
                    //sb.AppendLine($"{indentStr}{span}[{offset} + {field.Name}Length] = 0; // 终止符");
                    break;
                case LuminFiledType.List:
                    
                    if (!IsReferenceGenericType(field.GenericType.FirstOrDefault()))
                    {
                        sb.AppendLine($"{indentStr}var {field.Name}ListTempValue{depthSuffix} = {fieldPath};");
                        sb.AppendLine($"{indentStr}writer.WriteUnmanagedList(ref {offset}, ref {field.Name}ListTempValue{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                        sb.AppendLine($"{indentStr}var {field.Name}ListOffset{depthSuffix} = {offset} + {field.Name}TempLength{depthSuffix};");

                        if (isMultClass)
                            sb.AppendLine($"{indentStr}{offset} = {field.Name}ListOffset{depthSuffix};");
                        return;
                    }
                    
                    sb.AppendLine($"{indentStr}int {field.Name}Count{depthSuffix} = {fieldPath}.Count;");
                    //sb.AppendLine($"{indentStr}Unsafe.WriteUnaligned(ref {span}[{offset}], {field.Name}Count{depthSuffix});");
                    sb.AppendLine($"{indentStr}writer.WriteCollectionHeader(ref {offset}, {field.Name}Count{depthSuffix});");
                    sb.AppendLine($"{indentStr}int {field.Name}ListOffset{depthSuffix} = {offset} + 4;");

                    if (depth > 0)
                    {
                        sb.AppendLine($"{indentStr}var {field.Name}v{depthSuffix} = {fieldPath};");
                        sb.AppendLine($"{indentStr}var {field.Name}TempSpan{depthSuffix} = LuminPackMarshal.GetListSpan(ref {field.Name}v{depthSuffix}!);");
                    }
                    else 
                        sb.AppendLine($"{indentStr}var {field.Name}TempSpan{depthSuffix} = LuminPackMarshal.GetListSpan(ref {fieldPath}!);");
                    
                    
                    var elementField = new LuminDataField
                    {
                        Type = ConvertGenericsToFieldType(field.GenericType[0]),
                        ClassName = field.ClassName,
                        ClassFields = field.ClassFields,
                        ClassGenericType = field.ClassGenericType,
                        GenericType = field.GenericType.Skip(1).ToList()
                    };
                    
                    if (elementField.Type is LuminFiledType.Struct)
                    {
                        sb.AppendLine($"{indentStr}if (!writer.IsReferenceOrContainsReferences<{field.ClassName}>() && {field.Name}Count{depthSuffix} is not 0)");
                        sb.AppendLine($"{indentStr}{{");
                        sb.AppendLine($"{indentStr}    var {field.Name}ListTempValue{depthSuffix} = {fieldPath};");
                        sb.AppendLine($"{indentStr}    writer.WriteUnmanagedList(ref {offset}, ref {field.Name}ListTempValue{depthSuffix}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                        sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {field.Name}TempLength{depthSuffix};");
                        sb.AppendLine($"{indentStr}}}");
                        sb.AppendLine($"{indentStr}else");
                    }
                    
                    //sb.AppendLine($"{indentStr}for (int i{depthSuffix} = 0; i{depthSuffix} < {field.Name}Count{depthSuffix}; i{depthSuffix}++)");
                    sb.AppendLine($"{indentStr}foreach (var v{depthSuffix} in {field.Name}TempSpan{depthSuffix})");
                    sb.AppendLine($"{indentStr}{{");
    
                    
    
                    // 特殊处理字符串元素
                    if (elementField.Type is LuminFiledType.String)
                    {
                        //sb.AppendLine($"{indentStr}    if ({fieldPath}[i{depthSuffix}] == null)");
                        sb.AppendLine($"{indentStr}    if (v{depthSuffix} == null)");
                        sb.AppendLine($"{indentStr}    {{");
                        sb.AppendLine($"{indentStr}        writer.WriteNullStringHeader(ref {field.Name}ListOffset{depthSuffix});");
                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += writer.StringRecordLength();");
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                        
                        // 一次性获取字节数组并写入
                        //sb.AppendLine($"{indentStr}    int strLen_{depthSuffix} = System.Text.Encoding.UTF8.GetByteCount({fieldPath}[i{depthSuffix}]);");
                        //sb.AppendLine($"{indentStr}    System.Text.Encoding.UTF8.GetBytes({fieldPath}[i{depthSuffix}], {span}.Slice({field.Name}ListOffset{depthSuffix}, strLen_{depthSuffix}));");
                        //sb.AppendLine($"{indentStr}    {span}[{field.Name}ListOffset{depthSuffix} + strLen_{depthSuffix}] = 0;");
                        //sb.AppendLine($"{indentStr}    int strLen_{depthSuffix} = writer.GetStringLength({fieldPath}[i{depthSuffix}]);");
                        sb.AppendLine($"{indentStr}    int strLen_{depthSuffix} = writer.WriteString(ref {field.Name}ListOffset{depthSuffix}, v{depthSuffix});");
                        sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += strLen_{depthSuffix} + writer.StringRecordLength();");
                        
                        if (isMultClass)
                            sb.AppendLine($"{indentStr}    {offset} = {field.Name}ListOffset{depthSuffix};");
                    }
                    else if (elementField.Type is LuminFiledType.Class or LuminFiledType.Struct)
                    {
                        sb.AppendLine($"{indentStr}    var element = v{depthSuffix};");

                        if (elementField.Type is LuminFiledType.Class)
                        {
                            sb.AppendLine($"{indentStr}    if (element == null)");
                            sb.AppendLine($"{indentStr}    {{");
                            sb.AppendLine($"{indentStr}        writer.WriteNullObjectHeader(ref {field.Name}ListOffset{depthSuffix});");
                            sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                            sb.AppendLine($"{indentStr}        continue;");
                            sb.AppendLine($"{indentStr}    }}");
                        }
                        
                        sb.AppendLine($"{indentStr}    writer.WriteObjectHeader(ref {field.Name}ListOffset{depthSuffix}, {elementField.ClassFields.Count});");
                        sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += 1;");
                        sb.AppendLine();
                        
                        for (var i = 0; i < elementField.ClassFields.Count; i++)
                        {
                            var subField = elementField.ClassFields[i];
                            
                            if (subField.FieldType is LuminDataType.Reference)
                            {
                                if (subField.IsPrivate)
                                    sb.AppendLine($"{indentStr}    if (Get{field.Name}{subField.Name}(element) != null)");
                                else 
                                    sb.AppendLine($"{indentStr}    if (element.{subField.Name} != null)");
                                sb.AppendLine($"{indentStr}    {{");

                                if (subField.IsPrivate)
                                {
                                    GenerateSerializeCode(sb, subField, $"Get{field.Name}{subField.Name}(element)", span, $"{field.Name}ListOffset{depthSuffix}", indent + 2, depth + 1, true);
                                }
                                else
                                {
                                    GenerateSerializeCode(sb, subField, $"element.{subField.Name}", span, $"{field.Name}ListOffset{depthSuffix}", indent + 2, depth + 1, true);
                                }
                                
                                //sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += {GetFieldLength(subField, depth + 1)};");
                                
                                sb.AppendLine($"{indentStr}    }}");
                                sb.AppendLine($"{indentStr}    else");
                                sb.AppendLine($"{indentStr}    {{");
                                switch (subField.Type)
                                {
                                    case LuminFiledType.Array or LuminFiledType.List:
                                        sb.AppendLine($"{indentStr}        writer.WriteNullCollectionHeader(ref {field.Name}ListOffset{depthSuffix});");
                                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                                        break;
                                    case LuminFiledType.String:
                                        sb.AppendLine($"{indentStr}        writer.WriteNullStringHeader(ref {field.Name}ListOffset{depthSuffix});");
                                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += writer.StringRecordLength();");
                                        break;
                                    default:
                                        sb.AppendLine($"{indentStr}        writer.WriteNullObjectHeader(ref {field.Name}ListOffset{depthSuffix});");
                                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                                        break;
                                }
                                sb.AppendLine($"{indentStr}    }}");
                            }
                            else
                            {
                                
                                #region 连续值类型字段优化

                                if (IsUnmanagedFiledType(subField.Type))
                                {
                                    var num = FindNextUnmanagedType(elementField.ClassFields, i);

                                    if (num != i)
                                    {
                                        if (num - i >= 14)
                                        {
                                            num = i + 14;
                                        }
                            
                                        sb.Append($"{indentStr}    {field.Name}ListOffset{depthSuffix} += writer.WriteUnmanaged(ref {field.Name}ListOffset{depthSuffix}");
                                        for (var j = i; j <= num; j++)
                                        {
                                            if (elementField.ClassFields[j].IsPrivate)
                                                sb.Append($", Get{field.Name}{elementField.ClassFields[j].Name}(element)");
                                            else 
                                                sb.Append($", element.{elementField.ClassFields[j].Name}");
                                        }
                                        sb.Append(");");
                                        sb.AppendLine();
                                        i = num;
                                        continue;
                            
                                    }
                                }
                                #endregion
                                
                                if (subField.IsPrivate)
                                {
                                    GenerateSerializeCode(sb, subField, $"Get{field.Name}{subField.Name}(element)", span, $"{field.Name}ListOffset{depthSuffix}", indent + 2, depth + 1, true);
                                }
                                else
                                    GenerateSerializeCode(sb, subField, $"element.{subField.Name}", span, $"{field.Name}ListOffset{depthSuffix}", indent + 1, depth + 1, true);
                                //sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {GetFieldLength(subField, depth + 1, pattern: "writer")};");
                            }
                            
                        }
                    }
                    else
                    {
                        if (elementField.Type is LuminFiledType.Array or LuminFiledType.List)
                        {
                            sb.AppendLine($"{indentStr}    if (v{depthSuffix} == null)");
                            sb.AppendLine($"{indentStr}    {{");
                            sb.AppendLine($"{indentStr}        writer.WriteNullCollectionHeader(ref {field.Name}ListOffset{depthSuffix});");
                            sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                            sb.AppendLine($"{indentStr}        continue;");
                            sb.AppendLine($"{indentStr}    }}");
                        }
                        
                        GenerateSerializeCode(
                            sb,
                            elementField,
                            $"v{depthSuffix}",
                            span,
                            $"{field.Name}ListOffset{depthSuffix}",
                            indent + 1,
                            depth + 1
                        );
                        if(elementField.Type is LuminFiledType.List or LuminFiledType.Array) 
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} = {GetFieldLength(elementField, depth + 1, pattern: "writer")};");
                        else
                        {
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {GetFieldLength(elementField, depth + 1, pattern: "writer")};");
                        }
                    }
                    //sb.AppendLine($"{indentStr}    writer.FlushCurrentIndex({field.Name}ListOffset{depthSuffix});");
                    sb.AppendLine($"{indentStr}}}");
                    break;
                case LuminFiledType.Array:
                    
                    if (!IsReferenceGenericType(field.GenericType.FirstOrDefault()))
                    {
                        sb.AppendLine($"{indentStr}writer.WriteUnmanagedArray(ref {offset}, {fieldPath}, out var {field.Name}TempLength{depthSuffix});");
                        sb.AppendLine($"{indentStr}var {field.Name}ListOffset{depthSuffix} = {offset} + {field.Name}TempLength{depthSuffix};");
                        
                        if (isMultClass)
                            sb.AppendLine($"{indentStr}{offset} = {field.Name}ListOffset{depthSuffix};");
                        
                        return;
                    }
                    
                    var arrayElementField = new LuminDataField
                    {
                        Type = ConvertGenericsToFieldType(field.GenericType[0]),
                        ClassName = field.ClassName,
                        ClassFields = field.ClassFields,
                        ClassGenericType = field.ClassGenericType,
                        GenericType = field.GenericType.Skip(1).ToList(),
                    };
                    
                    sb.AppendLine($"{indentStr}int {field.Name}Count{depthSuffix} = {fieldPath}.Length;");
                    //sb.AppendLine($"{indentStr}Unsafe.WriteUnaligned(ref {span}[{offset}], {field.Name}Count{depthSuffix});");
                    sb.AppendLine($"{indentStr}writer.WriteCollectionHeader(ref {offset}, {field.Name}Count{depthSuffix});");
                    sb.AppendLine($"{indentStr}int {field.Name}ListOffset{depthSuffix} = {offset} + 4;");
                    sb.AppendLine($"{indentStr}var {field.Name}TempSpan{depthSuffix} = {fieldPath}.AsSpan();");
                    
                    if (arrayElementField.Type is LuminFiledType.Struct)
                    {
                        sb.AppendLine($"{indentStr}if (!writer.IsReferenceOrContainsReferences<{field.ClassName}>())");
                        sb.AppendLine($"{indentStr}{{");
                        sb.AppendLine($"{indentStr}    var tempArray{depthSuffix} = {fieldPath};");
                        sb.AppendLine($"{indentStr}    writer.WriteUnmanagedArray(ref {offset}, tempArray{depthSuffix}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                        sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {field.Name}TempLength{depthSuffix};");
                        sb.AppendLine($"{indentStr}}}");
                        sb.AppendLine($"{indentStr}else");
                    }
                    
                    
                    //sb.AppendLine($"{indentStr}for (int i{depthSuffix} = 0; i{depthSuffix} < {field.Name}Count{depthSuffix}; i{depthSuffix}++)");
                    sb.AppendLine($"{indentStr}foreach (var v{depthSuffix} in {field.Name}TempSpan{depthSuffix})");
                    sb.AppendLine($"{indentStr}{{");
    
                    
    
                    // 特殊处理字符串元素
                    if (arrayElementField.Type == LuminFiledType.String)
                    {
                        sb.AppendLine($"{indentStr}    if (v{depthSuffix} == null)");
                        sb.AppendLine($"{indentStr}    {{");
                        sb.AppendLine($"{indentStr}        writer.WriteNullStringHeader(ref {field.Name}ListOffset{depthSuffix});");
                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += writer.StringRecordLength();");
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                        
                        // 一次性获取字节数组并写入
                        //sb.AppendLine($"{indentStr}    int strLen_{depthSuffix} = System.Text.Encoding.UTF8.GetByteCount({fieldPath}[i{depthSuffix}]);");
                        //sb.AppendLine($"{indentStr}    System.Text.Encoding.UTF8.GetBytes({fieldPath}[i{depthSuffix}], {span}.Slice({field.Name}ListOffset{depthSuffix}, strLen_{depthSuffix}));");
                        //sb.AppendLine($"{indentStr}    {span}[{field.Name}ListOffset{depthSuffix} + strLen_{depthSuffix}] = 0;");
                        //sb.AppendLine($"{indentStr}    int strLen_{depthSuffix} = writer.GetStringLength({fieldPath}[i{depthSuffix}]);");
                        sb.AppendLine($"{indentStr}    int strLen_{depthSuffix} = writer.WriteString(ref {field.Name}ListOffset{depthSuffix}, v{depthSuffix});");
                        sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += strLen_{depthSuffix} + writer.StringRecordLength();");
                        
                        if (isMultClass)
                            sb.AppendLine($"{indentStr}    {offset} = {field.Name}ListOffset{depthSuffix};");
                    }
                    else if (arrayElementField.Type is LuminFiledType.Class or LuminFiledType.Struct)
                    {
                        
                        if (arrayElementField.Type is LuminFiledType.Class)
                        {
                            sb.AppendLine($"{indentStr}    if (v{depthSuffix} == null)");
                            sb.AppendLine($"{indentStr}    {{");
                            sb.AppendLine($"{indentStr}        writer.WriteNullObjectHeader(ref {field.Name}ListOffset{depthSuffix});");
                            sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                            sb.AppendLine($"{indentStr}        continue;");
                            sb.AppendLine($"{indentStr}    }}");
                        }
                        
                        sb.AppendLine($"{indentStr}    writer.WriteObjectHeader(ref {field.Name}ListOffset{depthSuffix}, {arrayElementField.ClassFields.Count});");
                        sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += 1;");
                        sb.AppendLine();
                        
                        for (var i = 0; i < arrayElementField.ClassFields.Count; i++)
                        {
                            var subField = arrayElementField.ClassFields[i];
                            
                            if (subField.FieldType is LuminDataType.Reference)
                            {
                                if (subField.IsPrivate)
                                    sb.AppendLine($"{indentStr}    if (Get{field.Name}{subField.Name}(v{depthSuffix}) != null)");
                                else 
                                    sb.AppendLine($"{indentStr}    if (v{depthSuffix}.{subField.Name} != null)");
                                sb.AppendLine($"{indentStr}    {{");
                                
                                if (subField.IsPrivate)
                                {
                                    GenerateSerializeCode(sb, subField, $"Get{field.Name}{subField.Name}(v{depthSuffix})", span, $"{field.Name}ListOffset{depthSuffix}", indent + 2, depth + 1, true);
                                }
                                else
                                {
                                    GenerateSerializeCode(sb, subField, $"v{depthSuffix}.{subField.Name}", span, $"{field.Name}ListOffset{depthSuffix}", indent + 2, depth + 1, true);
                                }
                                
                                //sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += {GetFieldLength(subField, depth + 1)};");
                                
                                sb.AppendLine($"{indentStr}    }}");
                                sb.AppendLine($"{indentStr}    else");
                                sb.AppendLine($"{indentStr}    {{");
                                switch (subField.Type)
                                {
                                    case LuminFiledType.Array or LuminFiledType.List:
                                        sb.AppendLine($"{indentStr}        writer.WriteNullCollectionHeader(ref {field.Name}ListOffset{depthSuffix});");
                                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                                        break;
                                    case LuminFiledType.String:
                                        sb.AppendLine($"{indentStr}        writer.WriteNullStringHeader(ref {field.Name}ListOffset{depthSuffix});");
                                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += writer.StringRecordLength();");
                                        break;
                                    default:
                                        sb.AppendLine($"{indentStr}        writer.WriteNullObjectHeader(ref {field.Name}ListOffset{depthSuffix});");
                                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                                        break;
                                }
                                sb.AppendLine($"{indentStr}    }}");
                            }
                            else
                            {
                                
                                #region 连续值类型字段优化

                                if (IsUnmanagedFiledType(subField.Type))
                                {
                                    var num = FindNextUnmanagedType(arrayElementField.ClassFields, i);

                                    if (num != i)
                                    {
                                        if (num - i >= 14)
                                        {
                                            num = i + 14;
                                        }
                            
                                        sb.Append($"{indentStr}    {field.Name}ListOffset{depthSuffix} += writer.WriteUnmanaged(ref {field.Name}ListOffset{depthSuffix}");
                                        for (var j = i; j <= num; j++)
                                        {
                                            if (arrayElementField.ClassFields[j].IsPrivate)
                                                sb.Append($", Get{field.Name}{arrayElementField.ClassFields[j].Name}(v{depthSuffix})");
                                            else
                                                sb.Append($", v{depthSuffix}.{arrayElementField.ClassFields[j].Name}");
                                        }
                                        sb.Append(");");
                                        sb.AppendLine();
                                        i = num;
                                        continue;
                            
                                    }
                                }
                                #endregion
                                
                                if (subField.IsPrivate)
                                {
                                    GenerateSerializeCode(sb, subField, $"Get{field.Name}{subField.Name}(v{depthSuffix})", span, $"{field.Name}ListOffset{depthSuffix}", indent + 1, depth + 1, true);
                                }
                                else
                                {
                                    GenerateSerializeCode(sb, subField, $"v{depthSuffix}.{subField.Name}", span, $"{field.Name}ListOffset{depthSuffix}", indent + 1, depth + 1, true);
                                }
                                
                                //sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {GetFieldLength(subField, depth + 1, pattern: "writer")};");
                            }
                            
                        }
                    }
                    else
                    {
                        
                        if (arrayElementField.Type is LuminFiledType.Array or LuminFiledType.List)
                        {
                            sb.AppendLine($"{indentStr}    if (v{depthSuffix} == null)");
                            sb.AppendLine($"{indentStr}    {{");
                            sb.AppendLine($"{indentStr}        writer.WriteNullCollectionHeader(ref {field.Name}ListOffset{depthSuffix});");
                            sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                            sb.AppendLine($"{indentStr}        continue;");
                            sb.AppendLine($"{indentStr}    }}");
                        }
                        
                        
                        GenerateSerializeCode(
                            sb,
                            arrayElementField,
                            $"v{depthSuffix}",
                            span,
                            $"{field.Name}ListOffset{depthSuffix}",
                            indent + 1,
                            depth + 1
                        );
                        if(arrayElementField.Type is LuminFiledType.List or LuminFiledType.Array) 
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} = {GetFieldLength(arrayElementField, depth + 1, pattern: "writer")};");
                        else
                        {
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {GetFieldLength(arrayElementField, depth + 1, pattern: "writer")};");
                        }
                    }
                    //sb.AppendLine($"{indentStr}    writer.FlushCurrentIndex({field.Name}ListOffset{depthSuffix});");
                    sb.AppendLine($"{indentStr}}}");
                    break;
                case LuminFiledType.Class:
                case LuminFiledType.Struct:
                    
                    sb.AppendLine($"{indentStr}// 序列化{field.ClassName}");
                    sb.AppendLine($"{indentStr}writer.WriteObjectHeader(ref {offset}, {field.ClassFields.Count});");
                    sb.AppendLine($"{indentStr}{offset} += 1;");
                    sb.AppendLine();
                    for (int i = 0; i < field.ClassFields.Count; i++)
                    {
                        var subField = field.ClassFields[i];
                        
                        if (subField.FieldType is LuminDataType.Reference)
                        {
                            if (subField.IsPrivate)
                                sb.AppendLine($"{indentStr}if (Get{field.Name}{subField.Name}({fieldPath}) != null)");
                            else 
                                sb.AppendLine($"{indentStr}if ({fieldPath}.{subField.Name} != null)");
                            sb.AppendLine($"{indentStr}{{");
                            
                            if (subField.IsPrivate)
                                GenerateSerializeCode(sb, subField, $"Get{field.Name}{subField.Name}({fieldPath})", span, offset, indent + 1, depth + 1, true);
                            else
                                GenerateSerializeCode(sb, subField, $"{fieldPath}.{subField.Name}", span, offset, indent + 1, depth + 1, true);
                            if (subField.Type is LuminFiledType.Array or LuminFiledType.List)
                            {
                                var newDepthSuffix = $"_{depth + 1}";
                                sb.AppendLine($"{indentStr}    writer.FlushCurrentIndex({subField.Name}ListOffset{newDepthSuffix});");
                            }
                            sb.AppendLine($"{indentStr}}}");
                            switch (subField.Type)
                            {
                                case LuminFiledType.List or LuminFiledType.Array:
                                    sb.AppendLine($"{indentStr}else");
                                    sb.AppendLine($"{indentStr}{{");
                                    sb.AppendLine($"{indentStr}    writer.WriteNullCollectionHeader(ref {offset});");
                                    sb.AppendLine($"{indentStr}    {offset} += 4;");
                                    sb.AppendLine($"{indentStr}}}"); break;
                                case LuminFiledType.String:
                                    sb.AppendLine($"{indentStr}else");
                                    sb.AppendLine($"{indentStr}{{");
                                    sb.AppendLine($"{indentStr}    writer.WriteNullStringHeader(ref {offset});");
                                    sb.AppendLine($"{indentStr}    {offset} += writer.StringRecordLength();");
                                    sb.AppendLine($"{indentStr}}}"); break;
                                default:
                                    sb.AppendLine($"{indentStr}else");
                                    sb.AppendLine($"{indentStr}{{");
                                    sb.AppendLine($"{indentStr}    writer.WriteNullObjectHeader(ref {offset});");
                                    sb.AppendLine($"{indentStr}    {offset} += 1;");
                                    sb.AppendLine($"{indentStr}}}"); break;
                            }
                        }
                        else
                        {
                            #region 连续值类型字段优化

                            if (IsUnmanagedFiledType(subField.Type))
                            {
                                var num = FindNextUnmanagedType(field.ClassFields, i);

                                if (num != i)
                                {
                                    if (num - i >= 14)
                                    {
                                        num = i + 14;
                                    }
                            
                                    sb.Append($"{indentStr}writer.Advance(writer.WriteUnmanaged(ref {offset}");
                                    for (var j = i; j <= num; j++)
                                    {
                                        if (field.ClassFields[j].IsPrivate) 
                                            sb.Append($", Get{field.Name}{field.ClassFields[j].Name}({fieldPath})");
                                        else 
                                            sb.Append($", {fieldPath}.{field.ClassFields[j].Name}");
                                    }
                                    sb.Append("));");
                                    sb.AppendLine();
                                    i = num;
                                    continue;
                            
                                }
                            }
                            #endregion
                            
                            if (subField.IsPrivate)
                                GenerateSerializeCode(sb, subField, $"Get{field.Name}{subField.Name}({fieldPath})", span, offset, indent, depth + 1, true);
                            else 
                                GenerateSerializeCode(sb, subField, $"{fieldPath}.{subField.Name}", span, offset, indent, depth + 1, true);
                        }
                        
                    }
                    break;
                case LuminFiledType.Enum:
                    
                    if (isMultClass)
                        sb.AppendLine($"{indentStr}writer.Advance(writer.WriteUnmanaged(ref {offset}, ({GetEnumTypeName(field.EnumType)}){fieldPath}));");
                    else
                        sb.AppendLine($"{indentStr}writer.WriteUnmanagedWithoutSizeReturn(ref {offset}, ({GetEnumTypeName(field.EnumType)}){fieldPath});");
                    break;
                case LuminFiledType.Other:
                default:
                    sb.AppendLine($"{indentStr}writer.WriteValue({fieldPath});"); break;
            }
        }

        private static void GenerateDeserializeCode(
            StringBuilder sb, LuminDataField field,
            string targetObj, string span,
            string offset, int indent, int depth,
            bool isFirst = true, string fieldPath = "", bool isArray = false, bool isList = false,
            string multList = "_", bool isPrivateFiled = false, string parentName = "")
        {
            string indentStr = new string(' ', indent * 4);
            string depthSuffix = $"{multList}{depth}";

            switch (field.Type)
            {
                case LuminFiledType.Byte:
                    if (isFirst) 
                        sb.AppendLine(isPrivateFiled 
                            ? $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj});"
                            : $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out byte {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj} = ({field.Name}TempValue{depthSuffix};");
                    }
                    break;
                case LuminFiledType.Bool:
                    if (isFirst) 
                        sb.AppendLine(isPrivateFiled 
                            ? $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj});"
                            : $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out bool {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj} = ({field.Name}TempValue{depthSuffix};");
                    }
                    
                    break;
                case LuminFiledType.Short:
                    if (isFirst) 
                        sb.AppendLine(isPrivateFiled 
                            ? $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj});"
                            : $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out short {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj} = {field.Name}TempValue{depthSuffix};");
                    }
                    break;
                case LuminFiledType.UShort:
                    if (isFirst) 
                        sb.AppendLine(isPrivateFiled 
                            ? $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj});"
                            : $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out ushort {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj} = {field.Name}TempValue{depthSuffix};");
                    }
                    
                    break;
                case LuminFiledType.Int:
                    if (isFirst)
                        sb.AppendLine(isPrivateFiled 
                            ? $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj});"
                            : $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out int {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj} = {field.Name}TempValue{depthSuffix};");
                    }
                    
                    break;
                case LuminFiledType.UInt:
                    if (isFirst) 
                        sb.AppendLine(isPrivateFiled
                            ? $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj});" 
                            : $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out uint {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj} = {field.Name}TempValue{depthSuffix};");
                    }
                    
                    break;
                case LuminFiledType.Long:
                    if (isFirst) 
                        sb.AppendLine(isPrivateFiled 
                            ? $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj});"
                            : $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out long {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj} = {field.Name}TempValue{depthSuffix};");
                    }
                    break;
                case LuminFiledType.ULong:
                    if (isFirst) 
                        sb.AppendLine(isPrivateFiled 
                            ? $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj});"
                            : $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out ulong {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj} = {field.Name}TempValue{depthSuffix};");
                    }
                    break;
                case LuminFiledType.Float:
                    if (isFirst) 
                        sb.AppendLine(isPrivateFiled 
                            ? $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj});"
                            : $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out float {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj} = {field.Name}TempValue{depthSuffix};");
                    }
                    break;
                case LuminFiledType.Double:
                    if (isFirst) 
                        sb.AppendLine(isPrivateFiled 
                            ? $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj});"
                            : $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out double {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj} = {field.Name}TempValue{depthSuffix};");
                    }
                    break;
                case LuminFiledType.String:
                    //sb.AppendLine($"{indentStr}int {field.Name}{depthSuffix}Length = 0;");
                   // sb.AppendLine($"{indentStr}while ({span}[{offset} + {field.Name}{depthSuffix}Length] != 0)");
                    //sb.AppendLine($"{indentStr}{{");
                    //sb.AppendLine($"{indentStr}    {field.Name}{depthSuffix}Length++;");
                    //sb.AppendLine($"{indentStr}}}");
                    sb.AppendLine($"{indentStr}reader.ReadStringLength(ref {offset}, out var {field.Name}{depthSuffix}Length);");
                    
                    //sb.AppendLine($"{indentStr}if ({field.Name}{depthSuffix}Length != 0)");
                    //sb.AppendLine($"{indentStr}{{");
                    if (isFirst && !isPrivateFiled)
                    {
                        //sb.AppendLine($"{indentStr}    {targetObj}.{field.Name} = System.Text.Encoding.UTF8.GetString({span}.Slice({offset}, {field.Name}{depthSuffix}Length));");
                        sb.AppendLine($"{indentStr}{targetObj}.{field.Name} = reader.ReadString({offset}, {field.Name}{depthSuffix}Length)!;");
                    }
                    else
                    {
                        //sb.AppendLine($"{indentStr}    {targetObj}.Add(System.Text.Encoding.UTF8.GetString({span}.Slice({offset}, {field.Name}{depthSuffix}Length)));");
                        sb.AppendLine($"{indentStr}{targetObj} = reader.ReadString({offset}, {field.Name}{depthSuffix}Length)!;");
                    }
                    //sb.AppendLine($"{indentStr}}}");
                    sb.AppendLine($"{indentStr}{offset} += {field.Name}{depthSuffix}Length + reader.StringRecordLength();");
                    
                    break;
                case LuminFiledType.List:
                    if (isFirst && depth is 0) 
                        //sb.AppendLine($"{indentStr}int {field.Name}Count{depthSuffix} = Unsafe.ReadUnaligned<int>(ref {span}[{offset}]);");
                        sb.AppendLine($"{indentStr}reader.TryReadCollectionHead(ref {offset}, out int {field.Name}Count{depthSuffix});");
                    
                    var elementField = new LuminDataField
                    {
                        Name = field.Name,
                        Type = ConvertGenericsToFieldType(field.GenericType[0]),
                        GenericType = field.GenericType.Skip(1).ToList(),
                        ClassName = field.ClassName,
                        ClassFields = field.ClassFields,
                        ClassGenericType = field.ClassGenericType,
                        ConstructParameterCount = field.ConstructParameterCount
                    };
                    
                    
                    // 明确泛型类型声明
                    string genericType = GetFullGenericTypeName(field.GenericType, elementField.ClassName, elementField.ClassGenericType);
                    if (isFirst) 
                        sb.AppendLine($"{indentStr}{targetObj}.{field.Name} = new List<{genericType}>({field.Name}Count{depthSuffix});");
                    
                    sb.AppendLine($"{indentStr}int {field.Name}ListOffset{depthSuffix} = {offset} + 4;");
                    
                    if (!IsReferenceGenericType(field.GenericType.FirstOrDefault()))
                    {
                        
                        if (depth > 0)
                        {
                            sb.AppendLine($"{indentStr}var {field.Name}TempSpan{depthSuffix} = LuminPackMarshal.GetListSpan(ref element__{depth - 1}, {field.Name}Count{depthSuffix});");
                            sb.AppendLine($"{indentStr}reader.ReadUnmanagedSpan(ref {field.Name}ListOffset{depthSuffix}, ref {field.Name}TempSpan{depthSuffix}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                            sb.AppendLine($"{indentStr}LuminPackMarshal.SetListSize(ref element__{depth - 1}, {field.Name}Count{depthSuffix});");
                        }
                        else
                        {
                            sb.AppendLine($"{indentStr}var {field.Name}TempSpan{depthSuffix} = LuminPackMarshal.GetListSpan(ref {targetObj}.{field.Name}!, {field.Name}Count{depthSuffix});");
                            sb.AppendLine($"{indentStr}reader.ReadUnmanagedSpan(ref {field.Name}ListOffset{depthSuffix}, ref {field.Name}TempSpan{depthSuffix}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                            sb.AppendLine($"{indentStr}LuminPackMarshal.SetListSize(ref {targetObj}.{field.Name}, {field.Name}Count{depthSuffix});");
                        }
                        
                        
                        sb.AppendLine($"{indentStr}{field.Name}ListOffset{depthSuffix} += {field.Name}TempLength{depthSuffix};");
                        
                        return;
                    }
                    
                    if (elementField.Type is LuminFiledType.Struct)
                    {
                        sb.AppendLine($"{indentStr}if (!reader.IsReferenceOrContainsReferences<{field.ClassName}>())");
                        sb.AppendLine($"{indentStr}{{");
                        if (depth > 0)
                        {
                            sb.AppendLine($"{indentStr}    var {field.Name}TempSpan{depthSuffix} = LuminPackMarshal.GetListSpan(ref element__{depth - 1}, {field.Name}Count{depthSuffix});");
                            sb.AppendLine($"{indentStr}    reader.ReadUnmanagedSpan(ref {offset}, ref {field.Name}TempSpan{depthSuffix}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                            sb.AppendLine($"{indentStr}    LuminPackMarshal.SetListSize(ref element__{depth - 1}, {field.Name}Count{depthSuffix});");
                        }
                        else
                        {
                            sb.AppendLine($"{indentStr}    var {field.Name}TempSpan{depthSuffix} = LuminPackMarshal.GetListSpan(ref {targetObj}.{field.Name}!, {field.Name}Count{depthSuffix});");
                            sb.AppendLine($"{indentStr}    reader.ReadUnmanagedSpan(ref {offset}, ref {field.Name}TempSpan{depthSuffix}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                            sb.AppendLine($"{indentStr}    LuminPackMarshal.SetListSize(ref {targetObj}.{field.Name}, {field.Name}Count{depthSuffix});");
                        }
                        
                        sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} = {field.Name}TempLength{depthSuffix} + 4;");
                        
                        sb.AppendLine($"{indentStr}}}");
                        
                        sb.AppendLine($"{indentStr}else");
                    }
                    
                    
                    
                    sb.AppendLine($"{indentStr}for (int i{depthSuffix} = 0; i{depthSuffix} < {field.Name}Count{depthSuffix}; i{depthSuffix}++)");
                    sb.AppendLine($"{indentStr}{{");
                    
                    if (depth > 0)
                    {
                        sb.AppendLine($"{indentStr}    var {field.Name}TempSpan{depthSuffix} = LuminPackMarshal.GetListSpan(ref {fieldPath}!, {field.Name}Count{depthSuffix});");
                    }
                    else 
                        sb.AppendLine($"{indentStr}    var {field.Name}TempSpan{depthSuffix} = LuminPackMarshal.GetListSpan(ref {targetObj}.{field.Name}!, {field.Name}Count{depthSuffix});");
                    
                    StringBuilder  arrayIndexFullSB = new StringBuilder();
                    if (isArray)
                    {
                        arrayIndexFullSB.Append($"[i{multList}{depth}]");
                    }
                    
                    
                    // 处理嵌套列表的初始化
                    if (elementField.Type is LuminFiledType.List)
                    {
                        //sb.AppendLine($"{indentStr}    reader.TryReadCollectionHead(ref {field.Name}ListOffset{depthSuffix}, out int {elementField.Name}Count_{depth + 1});");
                        
                        sb.AppendLine($"{indentStr}    if (!reader.TryReadCollectionHead(ref {field.Name}ListOffset{depthSuffix}, out int {elementField.Name}Count_{depth + 1}))");
                        sb.AppendLine($"{indentStr}    {{");
                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                        // if(isFirst) 
                        //     sb.AppendLine(isArray 
                        //         ? $"{indentStr}        {targetObj}.{field.Name}{arrayIndexFullSB} = default!;"
                        //         : $"{indentStr}        {targetObj}.{field.Name}.Add(default!);");
                        // else
                        //     sb.AppendLine(isArray 
                        //         ? $"{indentStr}        {targetObj}{arrayIndexFullSB} = default!;"
                        //         : $"{indentStr}        {targetObj}.Add(default!);");

                        sb.AppendLine($"{indentStr}        {field.Name}TempSpan{depthSuffix}[i{depthSuffix}] = default!;");
                        
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                        
                        // 生成嵌套泛型类型名称（例如 List<List<int>>）
                        string nestedGeneric = GetFullGenericTypeName(elementField.GenericType, elementField.ClassName, elementField.ClassGenericType);
                        sb.AppendLine($"{indentStr}    var element_{depthSuffix} = new List<{nestedGeneric}>({elementField.Name}Count_{depth + 1});");
                        
                        // if(isFirst) 
                        //     sb.AppendLine(isArray 
                        //         ? $"{indentStr}    {targetObj}.{field.Name}{arrayIndexFullSB} = element_{depthSuffix}" 
                        //         : $"{indentStr}    {targetObj}.{field.Name}.Add(element_{depthSuffix});");
                        // else
                        //     sb.AppendLine(isArray 
                        //         ? $"{indentStr}    {targetObj}{arrayIndexFullSB} = element_{depthSuffix};"
                        //         : $"{indentStr}    {targetObj}.Add(element_{depthSuffix});");
                        
                        sb.AppendLine($"{indentStr}    {field.Name}TempSpan{depthSuffix}[i{depthSuffix}] = element_{depthSuffix};");
                    }
                    else if (elementField.Type is LuminFiledType.Array)
                    {
                        var type = field.GenericType.Last();
                        
                        //sb.AppendLine($"{indentStr}    reader.TryReadCollectionHead(ref {field.Name}ListOffset{depthSuffix}, out int {elementField.Name}Count_{depth + 1});");
                        
                        sb.AppendLine($"{indentStr}    if (reader.TryReadCollectionHead(ref {field.Name}ListOffset{depthSuffix}, out int {elementField.Name}Count_{depth + 1}))");
                        sb.AppendLine($"{indentStr}    {{");
                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                        // if(isFirst) 
                        //     sb.AppendLine($"{indentStr}        {targetObj}.{field.Name}.Add(default!);");
                        // else
                        //     sb.AppendLine($"{indentStr}        {targetObj}.Add(default!);");
                        sb.AppendLine($"{indentStr}        {field.Name}TempSpan{depthSuffix}[i{depthSuffix}] = default!;");
                        
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                        StringBuilder array = new StringBuilder();

                        for (var i = 1; i < field.GenericType.Count; i++)
                        {
                            if (field.GenericType[i] is not LuminGenericsType.Array) break;
                            array.Append("[]");
                        }
                        
                        if (type is not LuminGenericsType.Struct and not LuminGenericsType.Class) 
                            sb.AppendLine($"{indentStr}    var element_{depthSuffix} = LuminPackMarshal.AllocateUninitializedArray<{GetGenericTypeName(type)}{array}>({elementField.Name}Count_{depth + 1});");
                        else
                            sb.AppendLine($"{indentStr}    var element_{depthSuffix} = LuminPackMarshal.AllocateUninitializedArray<{field.ClassName}{array}>({elementField.Name}Count_{depth + 1});");
                        
                        // if(isFirst) 
                        //     sb.AppendLine($"{indentStr}    {targetObj}.{field.Name}.Add(element_{depthSuffix});");
                        // else
                        //     sb.AppendLine($"{indentStr}    {targetObj}.Add(element_{depthSuffix});");
                        sb.AppendLine($"{indentStr}    {field.Name}TempSpan{depthSuffix}[i{depthSuffix}] = element_{depthSuffix};");
                    }
                    else if (elementField.Type is LuminFiledType.Class)
                    {
                        sb.AppendLine($"{indentStr}    if (reader.PeekIsNullObject(ref {field.Name}ListOffset{depthSuffix}))");
                        sb.AppendLine($"{indentStr}    {{");
                        //sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                        // if(isFirst) 
                        //     sb.AppendLine($"{indentStr}        {targetObj}.{field.Name}.Add(default!);");
                        // else
                        //     sb.AppendLine($"{indentStr}        {targetObj}.Add(default!);");
                        sb.AppendLine($"{indentStr}        {field.Name}TempSpan{depthSuffix}[i{depthSuffix}] = default!;");
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                    }
                    string elementPath = $"{field.Name}TempSpan{depthSuffix}[i{depthSuffix}]";
                    // 递归反序列化元素
                    // if (elementField.Type is LuminFiledType.List or LuminFiledType.Array)
                    // {
                    //     elementPath = isFirst ? $"{targetObj}.{field.Name}[i{depthSuffix}]" : $"{targetObj}[i{depthSuffix}]";
                    // }
                    // else
                    // {
                    //     elementPath = isFirst ? $"{targetObj}.{field.Name}" : $"{targetObj}";
                    // }
                    
                    GenerateDeserializeCode(
                        sb, 
                        elementField, 
                        elementPath,
                        span, 
                        $"{field.Name}ListOffset{depthSuffix}", 
                        indent + 1, 
                        depth + 1, 
                        false,
                        elementPath,
                        isArray: false,
                        isList: true,
                        multList,
                        parentName: parentName + $"{field.Name}"
                    );
                    
                    
                    
                    // 更新偏移量
                    if (elementField.Type is not LuminFiledType.String and not LuminFiledType.Class and not LuminFiledType.Struct) 
                        if(elementField.Type is LuminFiledType.List or LuminFiledType.Array) 
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} = {GetFieldLength(elementField, depth + 1)};");
                        else
                        {
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {GetFieldLength(elementField, depth + 1)};");
                        }
                    sb.AppendLine($"{indentStr}}}");
                    
                    break;
                case LuminFiledType.Array:
                    
                    if (isFirst) 
                        //sb.AppendLine($"{indentStr}int {field.Name}Count{depthSuffix} = Unsafe.ReadUnaligned<int>(ref {span}[{offset}]);");
                        sb.AppendLine($"{indentStr}reader.TryReadCollectionHead(ref {offset}, out int {field.Name}Count{depthSuffix});");
                    
                    var arrayElementField = new LuminDataField
                    {
                        Name = field.Name,
                        Type = ConvertGenericsToFieldType(field.GenericType[0]),
                        GenericType = field.GenericType.Skip(1).ToList(),
                        ClassName = field.ClassName,
                        ClassFields = field.ClassFields,
                        ClassGenericType = field.ClassGenericType,
                        ConstructParameterCount = field.ConstructParameterCount
                    };

                    StringBuilder arrayNum = new StringBuilder();

                    for (var i = 0; i < field.GenericType.Count; i++)
                    {
                        if (field.GenericType[i] is not LuminGenericsType.Array) break;
                        arrayNum.Append("[]");
                    }

                    if (isFirst)
                    {
                        var type = field.GenericType.Last();
                        
                        //如果是List，特殊处理
                        if (arrayElementField.Type is LuminFiledType.List)
                        {
                            string nestedGeneric = GetFullGenericTypeName(arrayElementField.GenericType, arrayElementField.ClassName, arrayElementField.ClassGenericType);
                            sb.AppendLine($"{indentStr}{targetObj}.{field.Name} = LuminPackMarshal.AllocateUninitializedArray<List<{nestedGeneric}>{arrayNum}>({field.Name}Count{depthSuffix});");
                        }
                        else
                        if (type is not LuminGenericsType.Struct and not LuminGenericsType.Class) 
                            sb.AppendLine($"{indentStr}{targetObj}.{field.Name} = LuminPackMarshal.AllocateUninitializedArray<{GetGenericTypeName(type)}{arrayNum}>({field.Name}Count{depthSuffix});");
                        else
                            sb.AppendLine($"{indentStr}{targetObj}.{field.Name} = LuminPackMarshal.AllocateUninitializedArray<{field.ClassName}{arrayNum}>({field.Name}Count{depthSuffix});");
                    }
                        
                    
                    sb.AppendLine($"{indentStr}int {field.Name}ListOffset{depthSuffix} = {offset} + 4;");
                    
                    
                    if (!IsReferenceGenericType(field.GenericType.FirstOrDefault()))
                    {
                        if (depth > 0) 
                            sb.AppendLine($"{indentStr}reader.ReadUnmanagedArray(ref {field.Name}ListOffset{depthSuffix}, ref element__{depth - 1}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                        else
                            sb.AppendLine($"{indentStr}reader.ReadUnmanagedArray(ref {field.Name}ListOffset{depthSuffix}, ref {targetObj}.{field.Name}!, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                        
                        sb.AppendLine($"{indentStr}{field.Name}ListOffset{depthSuffix} += {field.Name}TempLength{depthSuffix};");
                        
                        return;
                    }
                    
                    if (arrayElementField.Type is LuminFiledType.Struct)
                    {
                        sb.AppendLine($"{indentStr}if (!reader.IsReferenceOrContainsReferences<{field.ClassName}>())");
                        sb.AppendLine($"{indentStr}{{");
                        if (depth > 0) 
                            sb.AppendLine($"{indentStr}    reader.ReadUnmanagedArray(ref {offset}, ref element__{depth - 1}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                        else
                            sb.AppendLine($"{indentStr}    reader.ReadUnmanagedArray(ref {offset}, ref {targetObj}.{field.Name}!, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                        
                        sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {field.Name}TempLength{depthSuffix};");
                        
                        sb.AppendLine($"{indentStr}}}");
                        
                        sb.AppendLine($"{indentStr}else");
                    }
                    
                    sb.AppendLine($"{indentStr}for (int i{depthSuffix} = 0; i{depthSuffix} < {field.Name}Count{depthSuffix}; i{depthSuffix}++)");
                    sb.AppendLine($"{indentStr}{{");
                    
                    if (depth > 0)
                    {
                        sb.AppendLine($"{indentStr}    var {field.Name}TempSpan{depthSuffix} = {fieldPath}.AsSpan();");
                    }
                    else 
                        sb.AppendLine($"{indentStr}    var {field.Name}TempSpan{depthSuffix} = {targetObj}.{field.Name}.AsSpan();");
                    
                    
                    if (arrayElementField.Type is LuminFiledType.List)
                    {
                        //sb.AppendLine($"{indentStr}    reader.TryReadCollectionHead(ref {field.Name}ListOffset{depthSuffix}, out int {arrayElementField.Name}Count_{depth + 1});");
                        
                        sb.AppendLine($"{indentStr}    if (!reader.TryReadCollectionHead(ref {field.Name}ListOffset{depthSuffix}, out int {arrayElementField.Name}Count_{depth + 1}))");
                        sb.AppendLine($"{indentStr}    {{");
                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                        
                        // 生成嵌套泛型类型名称（例如 List<List<int>>）
                        string nestedGeneric = GetFullGenericTypeName(arrayElementField.GenericType, arrayElementField.ClassName, arrayElementField.ClassGenericType);
                        sb.AppendLine($"{indentStr}    var element_{depthSuffix} = new List<{nestedGeneric}>({arrayElementField.Name}Count_{depth + 1});");
                        
                        // if(isFirst) 
                        //     sb.AppendLine($"{indentStr}    {targetObj}.{field.Name}[i{depthSuffix}] = element_{depthSuffix};");
                        // else
                        //     sb.AppendLine($"{indentStr}    {targetObj}[i{depthSuffix}] = element_{depthSuffix};"); 
                        sb.AppendLine($"{indentStr}    {field.Name}TempSpan{depthSuffix}[i{depthSuffix}] = element_{depthSuffix};"); 
                        
                    }
                    else if (arrayElementField.Type is LuminFiledType.Array)
                    {
                        
                        //sb.AppendLine($"{indentStr}    reader.TryReadCollectionHead(ref {field.Name}ListOffset{depthSuffix}, out int {arrayElementField.Name}Count_{depth + 1});");
                        
                        sb.AppendLine($"{indentStr}    if (!reader.TryReadCollectionHead(ref {field.Name}ListOffset{depthSuffix}, out int {arrayElementField.Name}Count_{depth + 1}))");
                        sb.AppendLine($"{indentStr}    {{");
                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                        
                        StringBuilder array = new StringBuilder();

                        for (var i = 1; i < field.GenericType.Count; i++)
                        {
                            if (field.GenericType[i] is not LuminGenericsType.Array) break;
                            array.Append("[]");
                        }
                        var type = field.GenericType.Last();
                        if (type is not LuminGenericsType.Struct and not LuminGenericsType.Class) 
                            sb.AppendLine($"{indentStr}    var element_{depthSuffix} = LuminPackMarshal.AllocateUninitializedArray<{GetGenericTypeName(type)}{array}>({arrayElementField.Name}Count_{depth + 1});");
                        else
                            sb.AppendLine($"{indentStr}    var element_{depthSuffix} = LuminPackMarshal.AllocateUninitializedArray<{field.ClassName}{array}>({arrayElementField.Name}Count_{depth + 1});");
                        
                        //var targetObject = isFirst ? $"{targetObj}.{field.Name}[i{depthSuffix}]" : $"{targetObj}[i{depthSuffix}]";
                        sb.AppendLine($"{indentStr}    {field.Name}TempSpan{depthSuffix}[i{depthSuffix}] = element_{depthSuffix};");
                    }
                    else if (arrayElementField.Type is LuminFiledType.Class)
                    {
                        sb.AppendLine($"{indentStr}    if (reader.PeekIsNullObject(ref {field.Name}ListOffset{depthSuffix}))");
                        sb.AppendLine($"{indentStr}    {{");
                        //sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                    }
                    
                    string arrayElementPath = $"{field.Name}TempSpan{depthSuffix}[i{depthSuffix}]";
                    // // 递归反序列化元素
                    // if (arrayElementField.Type is LuminFiledType.Array or LuminFiledType.List)
                    // {
                    //     arrayElementPath = isFirst ? $"{targetObj}.{field.Name}[i{depthSuffix}]" : $"{targetObj}[i{depthSuffix}]";
                    // }
                    // else
                    // {
                    //     arrayElementPath = isFirst ? $"{targetObj}.{field.Name}" : $"{targetObj}";
                    // }
                    
                    GenerateDeserializeCode(
                        sb, 
                        arrayElementField, 
                        arrayElementPath,
                        span, 
                        $"{field.Name}ListOffset{depthSuffix}", 
                        indent + 1, 
                        depth + 1, 
                        false,
                        arrayElementPath,
                        isArray: true,
                        isList: false,
                        multList,
                        parentName: parentName + $"{field.Name}"
                    );
                    
                    // 更新偏移量
                    if (arrayElementField.Type is not LuminFiledType.String and not LuminFiledType.Class and not LuminFiledType.Struct) 
                        if(arrayElementField.Type is LuminFiledType.Array or LuminFiledType.List) 
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} = {GetFieldLength(arrayElementField, depth + 1)};");
                        else
                        {
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {GetFieldLength(arrayElementField, depth + 1)};");
                        }
                    sb.AppendLine($"{indentStr}}}");
                    
                    break;
                case LuminFiledType.Class:
                case LuminFiledType.Struct:
                    
                    sb.AppendLine($"{indentStr}// 反序列化{field.ClassName}");
                    sb.AppendLine($"{indentStr}{offset} += 1;");
                    sb.AppendLine($"{indentStr}var {parentName}{field.Name}{multList}Temp = new {GetFullTypeName(field)}({GetClassConstructParameter(field)});");

                    for (int i = 0; i < field.ClassFields.Count; i++)
                    {
                        var subField = field.ClassFields[i];

                        #region 连续值类型字段优化

                        if (IsUnmanagedFiledType(subField.Type))
                        {
                            var num = FindNextUnmanagedType(field.ClassFields, i);

                            if (num != i)
                            {
                                if (num - i >= 14)
                                {
                                    num = i + 14;
                                }
                            
                                sb.Append($"{indentStr}{offset} += reader.ReadUnmanaged(ref {offset}");
                                for (var j = i; j <= num; j++)
                                {
                                    if (field.ClassFields[j].IsPrivate)
                                        sb.Append($", out Get{field.Name}{field.ClassFields[j].Name}({parentName}{field.Name}{multList}Temp)");
                                    else
                                        sb.Append($", out {parentName}{field.Name}{multList}Temp.{field.ClassFields[j].Name}");
                                }
                                sb.Append(");");
                                sb.AppendLine();
                                i = num;
                                continue;
                            
                            }
                        }
                    
                        #endregion
                        
                        var indentTemp = indent;
                        
                        switch (subField.Type)
                        {
                            case LuminFiledType.Array or LuminFiledType.List:
                                sb.AppendLine($"{indentStr}if (reader.PeekIsNullCollection(ref {offset}))");
                                sb.AppendLine($"{indentStr}{{");
                                sb.AppendLine($"{indentStr}    {offset} += 4;");
                                sb.AppendLine($"{indentStr}}}"); 
                                sb.AppendLine($"{indentStr}else");
                                indentTemp += 1; break;
                            case LuminFiledType.Class:
                                sb.AppendLine($"{indentStr}if (reader.PeekIsNullObject(ref {offset}))");
                                sb.AppendLine($"{indentStr}{{");
                                sb.AppendLine($"{indentStr}    {offset} += 1;");
                                sb.AppendLine($"{indentStr}}}");
                                sb.AppendLine($"{indentStr}else"); 
                                indentTemp += 1; break;
                        }
                        
                        if (indentTemp != indent) 
                            sb.AppendLine($"{indentStr}{{");
                        
                        var classDepth = subField.Type is LuminFiledType.List or LuminFiledType.Array ? 0 : depth + 1;
                        
                        if (subField.IsPrivate)
                            GenerateDeserializeCode(sb, subField, $"Get{field.Name}{subField.Name}({parentName}{field.Name}{multList}Temp)", span, offset, indentTemp, classDepth, multList: multList + "_", isPrivateFiled: true, parentName: parentName + field.Name);
                        else
                            GenerateDeserializeCode(sb, subField, $"{parentName}{field.Name}{multList}Temp", span, offset, indentTemp, classDepth, multList: multList + "_", parentName: parentName + field.Name);

                        var newIdentStr = indentTemp == indent ? indentStr : $"{indentStr}    ";

                        if (field.ClassFields[i].Type
                            is not LuminFiledType.String
                            and not LuminFiledType.Class
                            and not LuminFiledType.Struct)
                        {
                            if (field.ClassFields[i].Type is LuminFiledType.Array or  LuminFiledType.List)
                                sb.AppendLine($"{newIdentStr}{offset} = {GetFieldLength(subField, classDepth, multList: multList + "_")};");
                            else 
                                sb.AppendLine($"{newIdentStr}{offset} += {GetFieldLength(subField, classDepth, multList: multList + "_")};");
                        }
                            
                        
                        if (indentTemp != indent) 
                            sb.AppendLine($"{indentStr}}}");
                    }
                    

                    if (isFirst && !isPrivateFiled)
                        sb.AppendLine($"{indentStr}{targetObj}.{field.Name} = {parentName}{field.Name}{multList}Temp;");
                    else 
                        sb.AppendLine($"{indentStr}{targetObj} = {parentName}{field.Name}{multList}Temp;");
                    // else if (isArray && isList)
                    // {
                    //     sb.AppendLine($"{indentStr}{targetObj}[i_{depth - 1}].Add({field.Name}{multList}Temp);");
                    // }
                    // else if (isArray && !isList)
                    //     sb.AppendLine($"{indentStr}{targetObj}[i_{depth - 1}] = {field.Name}{multList}Temp;");
                    // else
                    //     sb.AppendLine($"{indentStr}{targetObj} = {field.Name}{multList}Temp;");
                    break;
                case LuminFiledType.Enum:
                    if (isFirst) 
                        sb.AppendLine(isPrivateFiled 
                            ? $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn<{field.TypeName}>(ref {offset}, out {targetObj});"
                            : $"{indentStr}reader.ReadUnmanagedWithoutSizeReturn<{field.TypeName}>(ref {offset}, out {targetObj}.{field.Name});");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn<{field.TypeName}>(ref {offset}, out var {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj} = {field.Name}TempValue{depthSuffix};");
                    }
                    //sb.AppendLine($"{indentStr}reader.ReadUnmanaged<{field.TypeName}>(ref {offset}, out {targetObj}.{field.Name});");
                    break;
                case LuminFiledType.Other:
                default:
                    sb.AppendLine($"{indentStr}reader.ReadValue(ref {targetObj}.{field.Name});"); break;
            }
        }

        private static string GetEnumTypeName(LuminDataField field)
        {
            return $"{field.EnumType}";
        }

        private static string GetFullTypeName(LuminDataField field)
        {
            if (field.Type is LuminFiledType.Class or LuminFiledType.Struct || field.ClassName is not "Your Class Name" and not "" and not null)
            {
                var sb = new StringBuilder();
                if (!string.IsNullOrEmpty(field.NameSpace) && field.NameSpace != "Your Data NameSpace" && !field.ClassName.Contains("."))
                {
                    sb.Append($"{field.NameSpace}.");
                }
                sb.Append(field.ClassName); // 使用ClassName替代Name
                
                if (field.ClassName.Contains("<") || field.ClassName.Contains(">"))
                {
                    return sb.ToString();
                }
                
                if (!string.IsNullOrEmpty(field.ClassGenericType))
                {
                    sb.Append("<");
                    sb.Append(field.ClassGenericType);
                    sb.Append(">");
                }
                
                return sb.ToString();
            }
            return field.Type.ToString();
        }

        private static LuminFiledType ConvertGenericsToFieldType(LuminGenericsType genericType)
        {
            return genericType switch
            {
                LuminGenericsType.Byte => LuminFiledType.Byte,
                LuminGenericsType.Short => LuminFiledType.Short,
                LuminGenericsType.UShort => LuminFiledType.UShort,
                LuminGenericsType.Int => LuminFiledType.Int,
                LuminGenericsType.UInt => LuminFiledType.UInt,
                LuminGenericsType.Long => LuminFiledType.Long,
                LuminGenericsType.ULong => LuminFiledType.ULong,
                LuminGenericsType.Float => LuminFiledType.Float,
                LuminGenericsType.Double => LuminFiledType.Double,
                LuminGenericsType.String => LuminFiledType.String,
                LuminGenericsType.Bool => LuminFiledType.Bool,
                LuminGenericsType.Class => LuminFiledType.Class,
                LuminGenericsType.Struct => LuminFiledType.Struct,
                LuminGenericsType.List => LuminFiledType.List,
                LuminGenericsType.Array => LuminFiledType.Array,
                LuminGenericsType.Enum => LuminFiledType.Enum,
            };
        }
        
        private static LuminFiledType ConvertGenericsToFieldType(List<LuminGenericsType> genericTypes)
        {
            if (genericTypes.Count == 0)
                throw new ArgumentException("Empty generic types");

            var currentType = genericTypes[0];
            if (currentType == LuminGenericsType.List)
            {
                if (genericTypes.Count < 2)
                    throw new ArgumentException("Insufficient generic parameters for List");
                // 递归剥离泛型参数，直到找到非列表类型
                return ConvertGenericsToFieldType(genericTypes.Skip(1).ToList());
            }
            return currentType switch
            {
                LuminGenericsType.Byte => LuminFiledType.Byte,
                LuminGenericsType.Short => LuminFiledType.Short,
                LuminGenericsType.UShort => LuminFiledType.UShort,
                LuminGenericsType.Int => LuminFiledType.Int,
                LuminGenericsType.UInt => LuminFiledType.UInt,
                LuminGenericsType.Long => LuminFiledType.Long,
                LuminGenericsType.ULong => LuminFiledType.ULong,
                LuminGenericsType.Float => LuminFiledType.Float,
                LuminGenericsType.Double => LuminFiledType.Double,
                LuminGenericsType.Bool => LuminFiledType.Bool,
                LuminGenericsType.String => LuminFiledType.String,
                LuminGenericsType.Class => LuminFiledType.Class,
                LuminGenericsType.Struct => LuminFiledType.Struct,
                LuminGenericsType.Enum => LuminFiledType.Enum,
            };
        }

        private static string GetGenericTypeName(LuminGenericsType genericType)
        {
            return genericType switch
            {
                LuminGenericsType.Short => "short",
                LuminGenericsType.UShort => "ushort",
                LuminGenericsType.Int => "int",
                LuminGenericsType.UInt => "uint",
                LuminGenericsType.Long => "long",
                LuminGenericsType.ULong => "ulong",
                LuminGenericsType.Float => "float",
                LuminGenericsType.Double => "double",
                LuminGenericsType.String => "string",
                LuminGenericsType.Bool => "bool",
                LuminGenericsType.List => "List",
                LuminGenericsType.Enum => "Enum",
                _ => genericType.ToString()
            };
        }
        
        private static string GetEnumTypeName(LuminEnumFieldType genericType)
        {
            return genericType switch
            {
                LuminEnumFieldType.Byte => "byte",
                LuminEnumFieldType.Short => "short",
                LuminEnumFieldType.UShort => "ushort",
                LuminEnumFieldType.Int => "int",
                LuminEnumFieldType.UInt => "uint",
                LuminEnumFieldType.Long => "long",
                LuminEnumFieldType.ULong => "ulong",
                LuminEnumFieldType.Float => "float",
                LuminEnumFieldType.Double => "double",
            };
        }

        private static string GetFieldLength(LuminDataField field, int depth, string multList = "_", string pattern = "null")
        {
            string depthSuffix = $"{multList}{depth}";
            return field.Type switch
            {
                LuminFiledType.Byte => "1",
                LuminFiledType.Short => "2",
                LuminFiledType.UShort => "2",
                LuminFiledType.Int => "4",
                LuminFiledType.UInt => "4",
                LuminFiledType.Long => "8",
                LuminFiledType.ULong => "8",
                LuminFiledType.Float => "4",
                LuminFiledType.Double => "8",
                LuminFiledType.Bool => "1",
                LuminFiledType.String => pattern == "null" ? $"{field.Name}Length + 1" : $"{field.Name}Length + {pattern}.StringRecordLength()",
                LuminFiledType.List or LuminFiledType.Array => $"{field.Name}ListOffset{depthSuffix}",
                LuminFiledType.Class or LuminFiledType.Struct =>
                    string.Join(" + ", field.ClassFields.Select(sub => GetFieldLength(sub, depth + 1))),
                LuminFiledType.Enum => GetEnumFieldLength(field.EnumType),
                LuminFiledType.Other => "0"
            };
        }
        

        private static string GetEnumFieldLength(LuminEnumFieldType enumField)
        {
            return enumField switch
            {
                LuminEnumFieldType.Byte => "1",
                LuminEnumFieldType.Short => "2",
                LuminEnumFieldType.UShort => "2",
                LuminEnumFieldType.Int => "4",
                LuminEnumFieldType.UInt => "4",
                LuminEnumFieldType.Long => "8",
                LuminEnumFieldType.ULong => "8",
                LuminEnumFieldType.Float => "4",
                LuminEnumFieldType.Double => "8",
            };
        }

        private static string GetListLength(LuminDataField field, int depth)
        {
            string depthSuffix = $"_{depth}";
            var type = field.GenericType.Last();
            return type switch
            {
                LuminGenericsType.Byte => $"4 + {field.Name}Count{depthSuffix} * 1",
                LuminGenericsType.Bool => $"4 + ({field.Name}Count{depthSuffix} * 1)",
                LuminGenericsType.Short or LuminGenericsType.UShort => $"4 + ({field.Name}Count{depthSuffix} * 2)",
                LuminGenericsType.Int or LuminGenericsType.UInt => $"4 + ({field.Name}Count{depthSuffix} * 4)",
                LuminGenericsType.Long or LuminGenericsType.ULong => $"4 + ({field.Name}Count{depthSuffix} * 8)",
                LuminGenericsType.Float => $"4 + ({field.Name}Count{depthSuffix} * 4)",
                LuminGenericsType.Double => $"4 + ({field.Name}Count{depthSuffix} * 8)",
                LuminGenericsType.String => $"4 + {field.Name}Count{depthSuffix} * ({field.Name}Count{depthSuffix} + 1)",
                LuminGenericsType.Class => $"4 + {field.Name}Count{depthSuffix} * {field.Name}Count{depthSuffix}",
                LuminGenericsType.Struct => $"4 + {field.Name}Count{depthSuffix} * {field.Name}Count{depthSuffix}",
                LuminGenericsType.List => $"4 + {field.Name}Count{depthSuffix} * {field.Name}Count{depthSuffix}",
                LuminGenericsType.Enum => $"4 + {field.Name}Count{depthSuffix} * {GetEnumFieldLength(field.EnumType)}",
            };
        }
        
        private static string GetFullGenericTypeName(List<LuminGenericsType> genericTypes, string classname = "", string genericType = "")
        {
            if (genericTypes.Count == 0) throw new ArgumentException("Empty generic types");
            var currentType = genericTypes[0];
            if (currentType == LuminGenericsType.List)
            {
                return $"List<{GetFullGenericTypeName(genericTypes.Skip(1).ToList(), classname, genericType)}>";
            }
            
            if (currentType == LuminGenericsType.Array)
            {
                string elementType = GetFullGenericTypeName(
                    genericTypes.Skip(1).ToList(), 
                    classname
                );
                return $"{elementType}[]"; // 添加数组后缀
            }

            if (classname is not "" and not "Your Class Name")
            {

                if (genericType is not "" and not null)
                {
                    return $"{classname}<{genericType}>";
                }
                
                return currentType switch
                {
                    LuminGenericsType.Class => classname,
                    LuminGenericsType.Struct => classname,
                    _ => classname
                };
                
            }
            
            return GetGenericTypeName(currentType);
        }

        public static bool IsReferenceGenericType(LuminGenericsType? genericType) => genericType switch
        {
            LuminGenericsType.Byte => false,
            LuminGenericsType.Bool => false,
            LuminGenericsType.Short => false,
            LuminGenericsType.UShort => false,
            LuminGenericsType.Int => false,
            LuminGenericsType.UInt => false,
            LuminGenericsType.Long => false,
            LuminGenericsType.ULong => false,
            LuminGenericsType.Float => false,
            LuminGenericsType.Double => false,
            LuminGenericsType.Enum => false,
            LuminGenericsType.String => true,
            LuminGenericsType.Class => true,
            LuminGenericsType.Struct => true,
            LuminGenericsType.List => true,
            LuminGenericsType.Array => true,
            LuminGenericsType.Null => true
        };
        
        public static bool IsReferenceFiledType(LuminFiledType filedType) => filedType switch
        {
            LuminFiledType.Byte => false,
            LuminFiledType.Bool => false,
            LuminFiledType.Short => false,
            LuminFiledType.UShort => false,
            LuminFiledType.Int => false,
            LuminFiledType.UInt => false,
            LuminFiledType.Long => false,
            LuminFiledType.ULong => false,
            LuminFiledType.Float => false,
            LuminFiledType.Double => false,
            LuminFiledType.String => true,
            LuminFiledType.Class => true,
            LuminFiledType.Struct => true,
            LuminFiledType.List => true,
            LuminFiledType.Array => true,
            LuminFiledType.Enum => false,
        };

        public static bool IsUnmanagedFiledType(LuminFiledType filedType) => filedType switch
        {
            LuminFiledType.Byte => true,
            LuminFiledType.Bool => true,
            LuminFiledType.Short => true,
            LuminFiledType.UShort => true,
            LuminFiledType.Int => true,
            LuminFiledType.UInt => true,
            LuminFiledType.Long => true,
            LuminFiledType.ULong => true,
            LuminFiledType.Float => true,
            LuminFiledType.Double => true,
            LuminFiledType.Enum => true,
            _ => false
        };
        
        public static bool IsUnmanagedFiledType(string filedType) => filedType switch
        {
            "byte" => true,
            "bool" => true,
            "short" => true,
            "ushort" => true,
            "int" => true,
            "uint" => true,
            "long" => true,
            "ulong" => true,
            "float" => true,
            "double" => true,
            _ => false
        };
        
        private static bool IsFixedLengthType(LuminFiledType type)
        {
            return type switch
            {
                LuminFiledType.Byte    => true,
                LuminFiledType.Short   => true,
                LuminFiledType.UShort  => true,
                LuminFiledType.Int     => true,
                LuminFiledType.UInt    => true,
                LuminFiledType.Long    => true,
                LuminFiledType.ULong   => true,
                LuminFiledType.Float   => true,
                LuminFiledType.Double  => true,
                LuminFiledType.Bool    => true,
                LuminFiledType.Enum    => true,
                _                      => false // String/List/Class/Struct 为可变长度
            };
        }

        // 获取固定长度类型的字节长度表达式
        private static string GetFixedFieldLength(LuminDataField field)
        {
            return field.Type switch
            {
                LuminFiledType.Byte    => "1",
                LuminFiledType.Short   => "2",
                LuminFiledType.UShort  => "2",
                LuminFiledType.Int     => "4",
                LuminFiledType.UInt    => "4",
                LuminFiledType.Long    => "8",
                LuminFiledType.ULong   => "8",
                LuminFiledType.Float   => "4",
                LuminFiledType.Double  => "8",
                LuminFiledType.Bool    => "1",
                LuminFiledType.Enum    => GetEnumFieldLength(field.EnumType),
            };
        }
        
        // 获取数组维度（例如GenericType=[Array, Array, Int]返回2）
        private static int GetArrayDepth(List<LuminGenericsType> genericTypes)
        {
            int depth = 0;
            foreach (var type in genericTypes)
            {
                if (type == LuminGenericsType.Array) depth++;
                else break;
            }
            return depth;
        }

        // 生成数组类型名称（例如int[][]）
        private static string GetArrayTypeName(List<LuminGenericsType> genericTypes)
        {
            int depth = GetArrayDepth(genericTypes);
            var elementType = genericTypes.Last();
            string typeName = elementType switch
            {
                LuminGenericsType.Int => "int",
                LuminGenericsType.String => "string",
                // 其他类型映射...
                _ => "object"
            };
            return $"{typeName}{new string('[', depth)}{new string(']', depth)}";
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int FindNextUnmanagedType(LuminDataInfo data, int index)
        {
            for (var i = index + 1; i < data.fields.Count; i++)
            {
                if (!IsUnmanagedFiledType(data.fields[i].Type)) break;
                
                index++;
            }
            
            return index;
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int FindNextUnmanagedType(List<LuminDataField> data, int index)
        {
            for (var i = index + 1; i < data.Count; i++)
            {
                if (!IsUnmanagedFiledType(data[i].Type)) break;
                
                index++;
            }
            
            return index;
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool FindAllUnmanagedType(List<LuminDataField> datas)
        {
            foreach (var v in datas)
            {
                if (v.Type is LuminFiledType.Array or LuminFiledType.List or LuminFiledType.String or LuminFiledType.Other)
                {
                    return false;
                }

                if (v.Type is LuminFiledType.Class or LuminFiledType.Struct)
                {
                    if (!FindAllUnmanagedType(v.ClassFields)) return false;
                }
            }

            return true;
        }

        private static string GetClassConstructParameter(LuminDataField field)
        {
            StringBuilder sb = new StringBuilder();

            for (int i = 0; i < field.ConstructParameterCount; i++)
            {
                if (i is 0)
                    sb.Append("default");
                else
                    sb.Append(", default");
            }
            
            return sb.ToString();
        }

        private static void GeneratorUnsafeAccessorMethod(StringBuilder sb, LuminDataField baseField, List<LuminDataField> fileds)
        {
            foreach (var filed in fileds)
            {
                if (filed.ClassFields.Count > 0)
                {
                    GeneratorUnsafeAccessorMethod(sb, filed, filed.ClassFields);
                }
                    
                if (filed.IsPrivate)
                {
                    sb.AppendLine(filed.isProperty 
                        ? $@"        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = ""<{filed.Name}>k__BackingField"")]"
                        : $@"        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = ""{filed.Name}"")]");
                    sb.AppendLine($@"        public static extern ref {filed.TypeName} Get{baseField.Name}{filed.Name}({GetFullTypeName(baseField)} value);");
                    sb.AppendLine();
                }
            }
        }
    }
    
}