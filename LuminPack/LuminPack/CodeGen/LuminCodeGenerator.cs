
using System.Text;
using System.Runtime.CompilerServices;
using LuminPack.Enum;

#nullable enable
namespace LuminPack.CodeGen
{

    public static class LuminCodeGenerator
    {
        private static LuminDataInfo? _dataInfo;
        private static string? _currentClassName;
        
        static HashSet<string> defaultNamespace = new HashSet<string>()
        {
            "System",
            "System.Collections.Generic",
            "System.Runtime.CompilerServices",
            "System.Runtime.InteropServices",
            "System.Threading.Tasks",
            "LuminPack",
            "LuminPack.Data",
            "LuminPack.Code",
            "LuminPack.Core",
            "Your.Data.Namespace"
        };
        
        public static string CodeGenerator(LuminDataInfo data)
        {
            //缓存Info
            _dataInfo = data;
            
            StringBuilder sb = new StringBuilder();
            HashSet<string> namespaces = new HashSet<string>();

            // 收集需要的命名空间
            foreach (var field in data.fields)
            {
                if (!string.IsNullOrEmpty(field.NameSpace) &&
                    field.NameSpace != "Your Data NameSpace")
                {
                    namespaces.Add(field.NameSpace);
                }

                if (field.ClassFields.Count > 0)
                {
                    foreach (var classField in field.ClassFields)
                    {
                        if (!string.IsNullOrEmpty(classField.NameSpace) &&
                            classField.NameSpace != "Your Data NameSpace")
                        {
                            namespaces.Add(classField.NameSpace);
                        }
                    }
                }
            }

            //Setting
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("#pragma warning disable CS0108 // hides inherited member");
            sb.AppendLine("#pragma warning disable CS0162 // Unreachable code");
            sb.AppendLine("#pragma warning disable CS0164 // This label has not been referenced");
            sb.AppendLine("#pragma warning disable CS0219 // Variable assigned but never used");
            sb.AppendLine("#pragma warning disable CS0618 // Type or member is obsolete");
            sb.AppendLine("#pragma warning disable CS8600 // Converting null literal or possible null value to non - nullable type.");
            sb.AppendLine("#pragma warning disable CS8601 // Possible null reference assignment");
            sb.AppendLine("#pragma warning disable CS8602");
            sb.AppendLine("#pragma warning disable CS8604 // Possible null reference argument for parameter");
            sb.AppendLine("#pragma warning disable CS8619");
            sb.AppendLine("#pragma warning disable CS8620");
            sb.AppendLine("#pragma warning disable CS8631 // The type cannot be used as type parameter in the generic type or method");
            sb.AppendLine("#pragma warning disable CS8765 // Nullability of type of parameter");
            sb.AppendLine("#pragma warning disable CS9074 // The 'scoped' modifier of parameter doesn't match overridden or implemented member");
            sb.AppendLine("#pragma warning disable CA1050 // Declare types in namespaces.");

            sb.AppendLine();
            sb.AppendLine();
            
            // 基础命名空间
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine("using System.Runtime.InteropServices;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using LuminPack;");
            sb.AppendLine("using LuminPack.Data;");
            sb.AppendLine("using LuminPack.Code;");
            sb.AppendLine("using LuminPack.Core;");
            if (data.enableBurst)
                sb.AppendLine("using Unity.Burst;");

            // 自定义命名空间
            foreach (var ns in namespaces)
            {
                if (!defaultNamespace.Contains(ns)) 
                    sb.AppendLine($"using {ns};");
            }

            sb.AppendLine();

            // 类定义
            sb.AppendLine($"namespace LuminPack.Generated");
            sb.AppendLine("{");
            sb.AppendLine($"    public sealed class {data.className}Parser : LuminData<{data.className}>");
            sb.AppendLine("    {");

            // 静态构造函数注册
            sb.AppendLine($"        static {data.className}Parser()");
            sb.AppendLine("        {");
            sb.AppendLine($"            LuminPackParseProvider.Register(new {data.className}Parser());");
            sb.AppendLine("        }");
            sb.AppendLine();
            
            sb.AppendLine($"        private {data.className}Parser(){{}}");
            sb.AppendLine();
            
            sb.AppendLine($"        public override void RegisterParser()");
            sb.AppendLine("        {");
            sb.AppendLine($"            LuminPackParseProvider.RegisterDataHandler<{data.className}>(() => new {data.className}Parser());");
            sb.AppendLine($"            LuminPackParseProvider.RegisterAsyncHandler<{data.className}>(() => new {data.className}Parser());");
            sb.AppendLine("        }");
            sb.AppendLine();
            
            // Serialize实现
            sb.AppendLine("        [MethodImpl(MethodImplOptions.NoInlining)]");
            if (data.enableBurst)
                sb.AppendLine("        [BurstCompile]");
            sb.AppendLine("        public override byte[] Serialize()");
            sb.AppendLine("        {");
            sb.AppendLine("            if (_dataRef is null) return Array.Empty<byte>();");
            sb.AppendLine("            // 计算总字节长度");
            sb.AppendLine("            int totalLength = 0;");

            foreach (var field in data.fields)
            {
                if (field.FieldType is LuminDataType.Reference)
                {
                    if (field.Type is LuminFiledType.String)
                    {
                        sb.AppendLine($"            var {field.Name}Length = 0;");
                        sb.AppendLine($"            if (_dataRef.{field.Name} != null)");
                        sb.AppendLine("            {");
                        sb.AppendLine($"                {field.Name}Length = System.Text.Encoding.UTF8.GetByteCount(_dataRef.{field.Name});");
                        sb.AppendLine($"                totalLength += {field.Name}Length + 1;");
                        sb.AppendLine("            }");
                        sb.AppendLine("            else");
                        sb.AppendLine("            {");
                        sb.AppendLine($"                totalLength += 1;");
                        sb.AppendLine("            }");
                        
                        continue;
                    }
                    sb.AppendLine($"            if (_dataRef.{field.Name} != null)");
                    sb.AppendLine("            {");
                    GenerateSerializeLengthCode(sb, field, "_dataRef." + field.Name, 4, 0);
                    sb.AppendLine("            }");
                    switch (field.Type)
                    {
                        case LuminFiledType.Array or LuminFiledType.List:
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            sb.AppendLine($"                totalLength += 4;");
                            sb.AppendLine("            }"); break;
                        default:
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            sb.AppendLine($"                totalLength += 1;");
                            sb.AppendLine("            }"); break;
                    }
                }
                else
                {
                    GenerateSerializeLengthCode(sb, field, "_dataRef." + field.Name, 3, 0);
                }
                
            }

            sb.AppendLine("            var buffer = new byte[totalLength];");
            sb.AppendLine("            var span = new Span<byte>(buffer);");
            sb.AppendLine("            var writer = new LuminPackWriter(ref span);");
            sb.AppendLine("            int offset = 0;");

            for (var i = 0; i < data.fields.Count; i++)
            {
                if (data.fields[i].FieldType is LuminDataType.Reference)
                {
                    sb.AppendLine($"            if (_dataRef.{data.fields[i].Name} != null)");
                    sb.AppendLine("            {");
                    GenerateSerializeCode(sb, data.fields[i], "_dataRef." + data.fields[i].Name, "span", "offset", 4, 0);
                    if(i != data.fields.Count - 1) 
                        sb.AppendLine($"                offset += {GetFieldLength(data.fields[i], 0)};");
                    sb.AppendLine("            }");

                    switch (data.fields[i].Type)
                    {
                        case LuminFiledType.Array or LuminFiledType.List:
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            sb.AppendLine("                writer.WriteNullCollectionHeader(ref offset);");
                            if(i != data.fields.Count - 1) 
                                sb.AppendLine("                offset += 4;");
                            sb.AppendLine("            }"); break;
                        case LuminFiledType.String:
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            sb.AppendLine("                writer.WriteNullStringHeader(ref offset);");
                            if(i != data.fields.Count - 1) 
                                sb.AppendLine("                offset += 1;");
                            sb.AppendLine("            }"); break;
                        default:
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            sb.AppendLine("                writer.WriteNullObjectHeader(ref offset);");
                            if(i != data.fields.Count - 1) 
                                sb.AppendLine("                offset += 1;");
                            sb.AppendLine("            }"); break;
                    }
                    
                    
                }
                else
                {
                    #region 连续值类型字段优化

                    if (IsUnmanagedFiledType(data.fields[i].Type))
                    {
                        var num = FindNextUnmanagedType(data, i);

                        if (num != i)
                        {
                            sb.Append("            offset += writer.WriteUnmanaged(ref offset");
                            for (var j = i; j <= num; j++)
                            {
                                
                                sb.Append($", _dataRef.{data.fields[j].Name}");
                            }
                            sb.Append(");");
                            sb.AppendLine();
                            i = num;
                            continue;
                            
                        }
                    }
                    
                    #endregion
                    
                    
                    GenerateSerializeCode(sb, data.fields[i], "_dataRef." + data.fields[i].Name, "span", "offset", 3, 0);
                    
                    if(i == data.fields.Count - 1) break;
                    sb.AppendLine($"            offset += {GetFieldLength(data.fields[i], 0)};");
                }
                    
            }

            sb.AppendLine("            return buffer;");
            sb.AppendLine("        }");
            sb.AppendLine();

            // Deserialize实现
            sb.AppendLine("        [MethodImpl(MethodImplOptions.NoInlining)]");
            if (data.enableBurst)
                sb.AppendLine("        [BurstCompile]");
            sb.AppendLine($"        public override {data.className} Deserialize(byte[] data)");
            sb.AppendLine("        {");
            sb.AppendLine("            var span = new Span<byte>(data);");
            sb.AppendLine("            var reader = new LuminPackReader(ref span);");
            sb.AppendLine($"            var result = new {data.className}();");
            sb.AppendLine("            int offset = 0;");

            for (var i = 0; i < data.fields.Count; i++)
            {
                if (data.fields[i].FieldType is LuminDataType.Reference)
                {
                    switch (data.fields[i].Type)
                    {
                        case LuminFiledType.Array or LuminFiledType.List:
                            sb.AppendLine("            if (reader.PeekIsNullCollection(ref offset))");
                            sb.AppendLine("            {");
                            sb.AppendLine("                offset += 4;");
                            sb.AppendLine("            }");
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            GenerateDeserializeCode(sb, data.fields[i], "result", "span", "offset", 4, 0);
                    
                            if(i != data.fields.Count - 1 && data.fields[i].Type is not LuminFiledType.String)  
                                sb.AppendLine($"                offset += {GetFieldLength(data.fields[i], 0)};");
                            sb.AppendLine("            }");
                            break;
                        case LuminFiledType.String:
                            sb.AppendLine("            if (reader.PeekIsNullString(ref offset))");
                            sb.AppendLine("            {");
                            sb.AppendLine("                offset += 1;");
                            sb.AppendLine("            }");
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            GenerateDeserializeCode(sb, data.fields[i], "result", "span", "offset", 4, 0);
                    
                            if(i != data.fields.Count - 1 && data.fields[i].Type is not LuminFiledType.String) 
                                sb.AppendLine($"                offset += {GetFieldLength(data.fields[i], 0)};");
                            sb.AppendLine("            }");
                            break;
                        default:
                            sb.AppendLine("            if (reader.PeekIsNullObject(ref offset))");
                            sb.AppendLine("            {");
                            sb.AppendLine("                offset += 1;");
                            sb.AppendLine("            }");
                            sb.AppendLine("            else");
                            sb.AppendLine("            {");
                            GenerateDeserializeCode(sb, data.fields[i], "result", "span", "offset", 4, 0);
                            
                            if(i != data.fields.Count - 1 && data.fields[i].Type is not LuminFiledType.String) 
                                sb.AppendLine($"                offset += {GetFieldLength(data.fields[i], 0)};");
                            sb.AppendLine("            }");
                            break;
                    }
                }
                else
                {
                    
                    #region 连续值类型字段优化

                    if (IsUnmanagedFiledType(data.fields[i].Type))
                    {
                        var num = FindNextUnmanagedType(data, i);

                        if (num != i)
                        {
                            sb.Append("            offset += reader.ReadUnmanaged(ref offset");
                            for (var j = i; j <= num; j++)
                            {
                                
                                sb.Append($", out result.{data.fields[j].Name}");
                            }
                            sb.Append(");");
                            sb.AppendLine();
                            i = num;
                            continue;
                            
                        }
                    }
                    
                    #endregion
                    
                    GenerateDeserializeCode(sb, data.fields[i], "result", "span", "offset", 3, 0);
                    
                    if (data.fields[i].Type == LuminFiledType.String) continue;
                    if(i == data.fields.Count - 1) break;
                    sb.AppendLine($"            offset += {GetFieldLength(data.fields[i], 0)};");
                }
                
            }

            sb.AppendLine("            return result;");
            sb.AppendLine("        }");
            sb.AppendLine();

            // SerializeAsync实现
            sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("        public override async Task<byte[]> SerializeAsync()");
            sb.AppendLine("        {");
            sb.AppendLine("            return await Task.Run(Serialize);");
            sb.AppendLine("        }");
            sb.AppendLine();

            // DeserializeAsync实现
            sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        public override async Task<{data.className}> DeserializeAsync(byte[] data)");
            sb.AppendLine("        {");
            sb.AppendLine("            return await Task.Run(() => Deserialize(data));");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static void GenerateSerializeLengthCode(StringBuilder sb, LuminDataFiled field, string fieldPath, int indent, int depth)
        {
            string indentStr = new string(' ', indent * 4);
            string depthSuffix = $"_{depth}";

            switch (field.Type)
            {
                case LuminFiledType.Byte or LuminFiledType.Bool:
                    sb.AppendLine($"{indentStr}totalLength += 1;");
                    break;
                case LuminFiledType.Short:
                    sb.AppendLine($"{indentStr}totalLength += 2;");
                    break;
                case LuminFiledType.Int or LuminFiledType.Float:
                    sb.AppendLine($"{indentStr}totalLength += 4;");
                    break;
                case LuminFiledType.Long or  LuminFiledType.Double:
                    sb.AppendLine($"{indentStr}totalLength += 8;");
                    break;
                case LuminFiledType.String:
                    sb.AppendLine($"{indentStr}var {field.Name}Length = System.Text.Encoding.UTF8.GetByteCount({fieldPath});");
                    sb.AppendLine($"{indentStr}totalLength += {field.Name}Length + 1;");
                    break;
                case LuminFiledType.List:
                    var elementType = ConvertGenericsToFieldType(field.GenericType[0]);
                    bool isElementList = elementType == LuminFiledType.List;
    
                    if (!isElementList && IsFixedLengthType(elementType))
                    {
                        string elementLength = GetFixedFieldLength(new LuminDataFiled { Type = elementType });
                        if (depth > 0)
                            sb.AppendLine($"{indentStr}if ({fieldPath} == null) continue;");
                        sb.AppendLine($"{indentStr}totalLength += 4 + {fieldPath}.Count * {elementLength};");
                    }
                    else if (elementType is LuminFiledType.Class or LuminFiledType.Struct)
                    {
                        sb.AppendLine($"{indentStr}totalLength += 4; // 列表长度前缀");
                        if (depth > 0) 
                            sb.AppendLine($"{indentStr}if ({fieldPath} == null) continue;");
                        sb.AppendLine($"{indentStr}for (int i{depth} = 0; i{depth} < {fieldPath}.Count; i{depth}++)"); // 改为for循环
                        sb.AppendLine($"{indentStr}{{");
                        sb.AppendLine($"{indentStr}    var element = {fieldPath}[i{depth}];"); // 通过索引访问
                        
                        if (elementType is LuminFiledType.Class) 
                            sb.AppendLine($"{indentStr}    if (element == null) continue;");
                        
                        foreach (var subField in field.ClassFields)
                        {
                            if (subField.FieldType is LuminDataType.Reference)
                            {
                                sb.AppendLine($"{indentStr}    if (element.{subField.Name} != null)");
                                sb.AppendLine($"{indentStr}    {{");
                                GenerateSerializeLengthCode(sb, subField, "element." + subField.Name, indent + 2, depth + 1);
                                sb.AppendLine($"{indentStr}    }}");
                                switch (subField.Type)
                                {
                                    case LuminFiledType.List or LuminFiledType.Array:
                                        sb.AppendLine($"{indentStr}    else");
                                        sb.AppendLine($"{indentStr}    {{");
                                        sb.AppendLine($"{indentStr}        totalLength += 4;");
                                        sb.AppendLine($"{indentStr}    }}"); break;
                                    default:
                                        sb.AppendLine($"{indentStr}    else");
                                        sb.AppendLine($"{indentStr}    {{");
                                        sb.AppendLine($"{indentStr}        totalLength += 1;");
                                        sb.AppendLine($"{indentStr}    }}"); break;
                                }
                                
                            }
                            else
                                GenerateSerializeLengthCode(sb, subField, "element." + subField.Name, indent + 1, depth + 1);
                        }
                        sb.AppendLine($"{indentStr}}}");
                    }
                    else
                    {
                        // 处理嵌套列表或可变长度元素
                        sb.AppendLine($"{indentStr}totalLength += 4;");
                        if (depth > 0) 
                            sb.AppendLine($"{indentStr}if ({fieldPath} == null) continue;");
                        sb.AppendLine($"{indentStr}for (int i{depth} = 0; i{depth} < {fieldPath}.Count; i{depth}++)");
                        sb.AppendLine($"{indentStr}{{");
                        var elementField = new LuminDataFiled
                        {
                            Type = elementType, 
                            GenericType = field.GenericType.Skip(1).ToList(),
                            ClassFields = field.ClassFields,
                            ClassName = field.ClassName,
                            ClassGenericType = field.ClassGenericType
                        };
                        
                        if (elementType is LuminFiledType.String)
                        {
                            sb.AppendLine($"{indentStr}    if ({fieldPath}[i{depth}] == null)");
                            sb.AppendLine($"{indentStr}    {{");
                            sb.AppendLine($"{indentStr}        totalLength += 1;");
                            sb.AppendLine($"{indentStr}        continue;");
                            sb.AppendLine($"{indentStr}    }}");
                        }
                        
                        GenerateSerializeLengthCode(sb, elementField, $"{fieldPath}[i{depth}]", indent + 1, depth + 1);
                        sb.AppendLine($"{indentStr}}}");
                    }
                    break;
                case LuminFiledType.Array:
                    var arrayType = ConvertGenericsToFieldType(field.GenericType[0]);
                    bool isElementArray = arrayType == LuminFiledType.Array;
    
                    if (!isElementArray && IsFixedLengthType(arrayType))
                    {
                        string elementLength = GetFixedFieldLength(new LuminDataFiled { Type = arrayType });
                        if (depth > 0) 
                            sb.AppendLine($"{indentStr}if ({fieldPath} == null) continue;");
                        sb.AppendLine($"{indentStr}totalLength += 4 + {fieldPath}.Length * {elementLength};");
                    }
                    else if (arrayType is LuminFiledType.Class or LuminFiledType.Struct)
                    {
                        sb.AppendLine($"{indentStr}totalLength += 4; // 列表长度前缀");
                        if (depth > 0 && arrayType is LuminFiledType.Class) 
                            sb.AppendLine($"{indentStr}if ({fieldPath} == null) continue;");
                        sb.AppendLine($"{indentStr}for (int i{depth} = 0; i{depth} < {fieldPath}.Length; i{depth}++)"); // 改为for循环
                        sb.AppendLine($"{indentStr}{{");
                        
                        foreach (var subField in field.ClassFields)
                        {
                            if (subField.FieldType is LuminDataType.Reference)
                            {
                                sb.AppendLine($"{indentStr}    if ({fieldPath}[i{depth}].{subField.Name} != null)");
                                sb.AppendLine($"{indentStr}    {{");
                                GenerateSerializeLengthCode(sb, subField, $"{fieldPath}[i{depth}]." + subField.Name, indent + 2, depth + 1);
                                sb.AppendLine($"{indentStr}    }}");
                                switch (subField.Type)
                                {
                                    case LuminFiledType.List or LuminFiledType.Array:
                                        sb.AppendLine($"{indentStr}    else");
                                        sb.AppendLine($"{indentStr}    {{");
                                        sb.AppendLine($"{indentStr}        totalLength += 4;");
                                        sb.AppendLine($"{indentStr}    }}"); break;
                                    default:
                                        sb.AppendLine($"{indentStr}    else");
                                        sb.AppendLine($"{indentStr}    {{");
                                        sb.AppendLine($"{indentStr}        totalLength += 1;");
                                        sb.AppendLine($"{indentStr}    }}"); break;
                                }
                            }
                            else
                                GenerateSerializeLengthCode(sb, subField, $"{fieldPath}[i{depth}]." + subField.Name, indent + 1, depth + 1);
                            
                        }
                        sb.AppendLine($"{indentStr}}}");
                    }
                    else
                    {
                        // 处理嵌套列表或可变长度元素
                        sb.AppendLine($"{indentStr}totalLength += 4;");
                        if (depth > 0) 
                            sb.AppendLine($"{indentStr}if ({fieldPath} == null) continue;");
                        sb.AppendLine($"{indentStr}for (int i{depth} = 0; i{depth} < {fieldPath}.Length; i{depth}++)");
                        sb.AppendLine($"{indentStr}{{");
                        var elementField = new LuminDataFiled
                        {
                            Type = arrayType, 
                            FieldType = field.FieldType,
                            GenericType = field.GenericType.Skip(1).ToList(),
                            ClassFields = field.ClassFields,
                            ClassName = field.ClassName,
                            ClassGenericType = field.ClassGenericType
                        };
                        
                        if (arrayType is LuminFiledType.String)
                        {
                            sb.AppendLine($"{indentStr}    if ({fieldPath}[i{depth}] == null)");
                            sb.AppendLine($"{indentStr}    {{");
                            sb.AppendLine($"{indentStr}        totalLength += 1;");
                            sb.AppendLine($"{indentStr}        continue;");
                            sb.AppendLine($"{indentStr}    }}");
                        }
                            
                        GenerateSerializeLengthCode(sb, elementField, $"{fieldPath}[i{depth}]", indent + 1, depth + 1);
                        sb.AppendLine($"{indentStr}}}");
                    }
                    break;
                case LuminFiledType.Class:
                case LuminFiledType.Struct:
                    
                    _currentClassName = field.ClassName;
                    
                    sb.AppendLine($"{indentStr}// {field.ClassName}长度计算");
                    for (int i = 0; i < field.ClassFields.Count; i++)
                    {
                        var subField = field.ClassFields[i];
                        if (subField.FieldType is LuminDataType.Reference)
                        {
                            sb.AppendLine($"{indentStr}if ({fieldPath}.{subField.Name} != null)");
                            sb.AppendLine($"{indentStr}{{");
                            GenerateSerializeLengthCode(sb, subField, $"{fieldPath}.{subField.Name}", indent + 1, depth + 1);
                            sb.AppendLine($"{indentStr}}}");
                            switch (subField.Type)
                            {
                                case LuminFiledType.List or LuminFiledType.Array:
                                    sb.AppendLine($"{indentStr}else");
                                    sb.AppendLine($"{indentStr}{{");
                                    sb.AppendLine($"{indentStr}    totalLength += 4;");
                                    sb.AppendLine($"{indentStr}}}"); break;
                                default:
                                    sb.AppendLine($"{indentStr}else");
                                    sb.AppendLine($"{indentStr}{{");
                                    sb.AppendLine($"{indentStr}    totalLength += 1;");
                                    sb.AppendLine($"{indentStr}}}"); break;
                            }
                        }
                        else 
                            GenerateSerializeLengthCode(sb, subField, $"{fieldPath}.{subField.Name}", indent, depth + 1);
                        
                    }
                    break;
                case LuminFiledType.Enum:
                    sb.AppendLine($"{indentStr}totalLength += {GetEnumFieldLength(field.EnumType)};");
                    break;
                default:
                    throw new ArgumentException($"Unsupported type: {field.Type}");
            }
        }


        private static void GenerateSerializeCode(StringBuilder sb, LuminDataFiled field, string fieldPath, string span, string offset, int indent, int depth)
        {
            string indentStr = new string(' ', indent * 4);
            string depthSuffix = $"_{depth}";

            switch (field.Type)
            {
                case LuminFiledType.Byte:
                    sb.AppendLine($"{indentStr}{span}[{offset}] = {fieldPath};");
                    break;
                case LuminFiledType.Bool:
                    sb.AppendLine($"{indentStr}writer.WriteUnmanagedWithoutSizeReturn(ref {offset}, {fieldPath});");
                    break;
                case LuminFiledType.Short:
                    sb.AppendLine($"{indentStr}writer.WriteUnmanagedWithoutSizeReturn(ref {offset}, {fieldPath});");
                    break;
                case LuminFiledType.Int:
                case LuminFiledType.Float:
                    sb.AppendLine($"{indentStr}writer.WriteUnmanagedWithoutSizeReturn(ref {offset}, {fieldPath});");
                    break;
                case LuminFiledType.Long:
                case LuminFiledType.Double:
                    sb.AppendLine($"{indentStr}writer.WriteUnmanagedWithoutSizeReturn(ref {offset}, {fieldPath});");
                    break;
                case LuminFiledType.String:
                    sb.AppendLine($"{indentStr}writer.WriteString(ref {offset}, {fieldPath}, {field.Name}Length);");
                    //sb.AppendLine($"{indentStr}System.Text.Encoding.UTF8.GetBytes({fieldPath}, {span}.Slice({offset}, {field.Name}Length));");
                    //sb.AppendLine($"{indentStr}{span}[{offset} + {field.Name}Length] = 0; // 终止符");
                    break;
                case LuminFiledType.List:
                    
                    if (!IsReferenceGenericType(field.GenericType.FirstOrDefault()))
                    {
                        sb.AppendLine($"{indentStr}var {field.Name}ListTempValue{depthSuffix} = {fieldPath};");
                        sb.AppendLine($"{indentStr}writer.WriteUnmanagedList(ref {offset}, ref {field.Name}ListTempValue{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                        sb.AppendLine($"{indentStr}var {field.Name}ListOffset{depthSuffix} = {offset} + {field.Name}TempLength{depthSuffix};");
                        
                        return;
                    }
                    
                    sb.AppendLine($"{indentStr}int {field.Name}Count{depthSuffix} = {fieldPath}.Count;");
                    //sb.AppendLine($"{indentStr}Unsafe.WriteUnaligned(ref {span}[{offset}], {field.Name}Count{depthSuffix});");
                    sb.AppendLine($"{indentStr}writer.WriteCollectionHeader(ref {offset}, {field.Name}Count{depthSuffix});");
                    sb.AppendLine($"{indentStr}int {field.Name}ListOffset{depthSuffix} = {offset} + 4;");
                    
                    var elementField = new LuminDataFiled
                    {
                        Type = ConvertGenericsToFieldType(field.GenericType[0]),
                        ClassName = field.ClassName,
                        ClassFields = field.ClassFields,
                        ClassGenericType = field.ClassGenericType,
                        GenericType = field.GenericType.Skip(1).ToList()
                    };
                    
                    if (elementField.Type is LuminFiledType.Struct)
                    {
                        sb.AppendLine($"{indentStr}if (!writer.IsReferenceOrContainsReferences<{field.ClassName}>() && {field.Name}Count{depthSuffix} is not 0)");
                        sb.AppendLine($"{indentStr}{{");
                        sb.AppendLine($"{indentStr}    var {field.Name}ListTempValue{depthSuffix} = {fieldPath};");
                        sb.AppendLine($"{indentStr}    writer.WriteUnmanagedList(ref {offset}, ref {field.Name}ListTempValue{depthSuffix}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                        sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {field.Name}TempLength{depthSuffix};");
                        sb.AppendLine($"{indentStr}}}");
                        sb.AppendLine($"{indentStr}else");
                    }
                    
                    sb.AppendLine($"{indentStr}for (int i{depthSuffix} = 0; i{depthSuffix} < {field.Name}Count{depthSuffix}; i{depthSuffix}++)");
                    sb.AppendLine($"{indentStr}{{");
    
                    
    
                    // 特殊处理字符串元素
                    if (elementField.Type is LuminFiledType.String)
                    {
                        sb.AppendLine($"{indentStr}    if ({fieldPath}[i{depthSuffix}] == null)");
                        sb.AppendLine($"{indentStr}    {{");
                        sb.AppendLine($"{indentStr}        writer.WriteNullStringHeader(ref {field.Name}ListOffset{depthSuffix});");
                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                        
                        // 一次性获取字节数组并写入
                        sb.AppendLine($"{indentStr}    int strLen_{depthSuffix} = System.Text.Encoding.UTF8.GetByteCount({fieldPath}[i{depthSuffix}]);");
                        sb.AppendLine($"{indentStr}    System.Text.Encoding.UTF8.GetBytes({fieldPath}[i{depthSuffix}], {span}.Slice({field.Name}ListOffset{depthSuffix}, strLen_{depthSuffix}));");
                        sb.AppendLine($"{indentStr}    {span}[{field.Name}ListOffset{depthSuffix} + strLen_{depthSuffix}] = 0;");
                        sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += strLen_{depthSuffix} + 1;");
                    }
                    else if (elementField.Type is LuminFiledType.Class or LuminFiledType.Struct)
                    {
                        sb.AppendLine($"{indentStr}    var element = {fieldPath}[i{depthSuffix}];");

                        if (elementField.Type is LuminFiledType.Class)
                        {
                            sb.AppendLine($"{indentStr}    if (element == null)");
                            sb.AppendLine($"{indentStr}    {{");
                            sb.AppendLine($"{indentStr}        writer.WriteNullObjectHeader(ref {field.Name}ListOffset{depthSuffix});");
                            sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                            sb.AppendLine($"{indentStr}        continue;");
                            sb.AppendLine($"{indentStr}    }}");
                        }
                        
                            
                        
                        foreach (var subField in elementField.ClassFields)
                        {
                            if (subField.FieldType is LuminDataType.Reference)
                            {
                                sb.AppendLine($"{indentStr}    if (element.{subField.Name} != null)");
                                sb.AppendLine($"{indentStr}    {{");
                                
                                if (subField.Type is LuminFiledType.String) 
                                    sb.AppendLine($"{indentStr}        var {subField.Name}Length = System.Text.Encoding.UTF8.GetByteCount(element.{subField.Name});");
                                GenerateSerializeCode(sb, subField, $"element.{subField.Name}", span, $"{field.Name}ListOffset{depthSuffix}", indent + 2, depth + 1);
                                sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += {GetFieldLength(subField, depth + 1)};");
                                
                                sb.AppendLine($"{indentStr}    }}");
                                sb.AppendLine($"{indentStr}    else");
                                sb.AppendLine($"{indentStr}    {{");
                                switch (subField.Type)
                                {
                                    case LuminFiledType.Array or LuminFiledType.List:
                                        sb.AppendLine($"{indentStr}        writer.WriteNullCollectionHeader(ref {field.Name}ListOffset{depthSuffix});");
                                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                                        break;
                                    case LuminFiledType.String:
                                        sb.AppendLine($"{indentStr}        writer.WriteNullStringHeader(ref {field.Name}ListOffset{depthSuffix});");
                                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                                        break;
                                    default:
                                        sb.AppendLine($"{indentStr}        writer.WriteNullObjectHeader(ref {field.Name}ListOffset{depthSuffix});");
                                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                                        break;
                                }
                                sb.AppendLine($"{indentStr}    }}");
                            }
                            else
                            {
                                if (subField.Type is LuminFiledType.String) 
                                    sb.AppendLine($"{indentStr}    var {subField.Name}Length = System.Text.Encoding.UTF8.GetByteCount(element.{subField.Name});");
                                GenerateSerializeCode(sb, subField, $"element.{subField.Name}", span, $"{field.Name}ListOffset{depthSuffix}", indent + 1, depth + 1);
                                sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {GetFieldLength(subField, depth + 1)};");
                            }
                            
                        }
                    }
                    else
                    {
                        if (elementField.Type is LuminFiledType.Array or LuminFiledType.List)
                        {
                            sb.AppendLine($"{indentStr}    if ({fieldPath}[i{depthSuffix}] == null)");
                            sb.AppendLine($"{indentStr}    {{");
                            sb.AppendLine($"{indentStr}        writer.WriteNullCollectionHeader(ref {field.Name}ListOffset{depthSuffix});");
                            sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                            sb.AppendLine($"{indentStr}        continue;");
                            sb.AppendLine($"{indentStr}    }}");
                        }
                        
                        GenerateSerializeCode(
                            sb,
                            elementField,
                            $"{fieldPath}[i{depthSuffix}]",
                            span,
                            $"{field.Name}ListOffset{depthSuffix}",
                            indent + 1,
                            depth + 1
                        );
                        if(elementField.Type is LuminFiledType.List or LuminFiledType.Array) 
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} = {GetFieldLength(elementField, depth + 1)};");
                        else
                        {
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {GetFieldLength(elementField, depth + 1)};");
                        }
                    }
    
                    sb.AppendLine($"{indentStr}}}");
                    break;
                case LuminFiledType.Array:
                    
                    if (!IsReferenceGenericType(field.GenericType.FirstOrDefault()))
                    {
                        sb.AppendLine($"{indentStr}writer.WriteUnmanagedArray(ref {offset}, {fieldPath}, out var {field.Name}TempLength{depthSuffix});");
                        sb.AppendLine($"{indentStr}var {field.Name}ListOffset{depthSuffix} = {offset} + {field.Name}TempLength{depthSuffix};");
                        
                        return;
                    }
                    
                    var arrayElementField = new LuminDataFiled
                    {
                        Type = ConvertGenericsToFieldType(field.GenericType[0]),
                        ClassName = field.ClassName,
                        ClassFields = field.ClassFields,
                        ClassGenericType = field.ClassGenericType,
                        GenericType = field.GenericType.Skip(1).ToList(),
                    };
                    
                    sb.AppendLine($"{indentStr}int {field.Name}Count{depthSuffix} = {fieldPath}.Length;");
                    //sb.AppendLine($"{indentStr}Unsafe.WriteUnaligned(ref {span}[{offset}], {field.Name}Count{depthSuffix});");
                    sb.AppendLine($"{indentStr}writer.WriteCollectionHeader(ref {offset}, {field.Name}Count{depthSuffix});");
                    sb.AppendLine($"{indentStr}int {field.Name}ListOffset{depthSuffix} = {offset} + 4;");
                    
                    if (arrayElementField.Type is LuminFiledType.Struct)
                    {
                        sb.AppendLine($"{indentStr}if (!writer.IsReferenceOrContainsReferences<{field.ClassName}>())");
                        sb.AppendLine($"{indentStr}{{");
                        sb.AppendLine($"{indentStr}    var tempArray{depthSuffix} = {fieldPath};");
                        sb.AppendLine($"{indentStr}    writer.WriteUnmanagedArray(ref {offset}, tempArray{depthSuffix}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                        sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {field.Name}TempLength{depthSuffix};");
                        sb.AppendLine($"{indentStr}}}");
                        sb.AppendLine($"{indentStr}else");
                    }
                    
                    
                    sb.AppendLine($"{indentStr}for (int i{depthSuffix} = 0; i{depthSuffix} < {field.Name}Count{depthSuffix}; i{depthSuffix}++)");
                    sb.AppendLine($"{indentStr}{{");
    
                    
    
                    // 特殊处理字符串元素
                    if (arrayElementField.Type == LuminFiledType.String)
                    {
                        sb.AppendLine($"{indentStr}    if ({fieldPath}[i{depthSuffix}] == null)");
                        sb.AppendLine($"{indentStr}    {{");
                        sb.AppendLine($"{indentStr}        writer.WriteNullStringHeader(ref {field.Name}ListOffset{depthSuffix});");
                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                        
                        // 一次性获取字节数组并写入
                        sb.AppendLine($"{indentStr}    int strLen_{depthSuffix} = System.Text.Encoding.UTF8.GetByteCount({fieldPath}[i{depthSuffix}]);");
                        sb.AppendLine($"{indentStr}    System.Text.Encoding.UTF8.GetBytes({fieldPath}[i{depthSuffix}], {span}.Slice({field.Name}ListOffset{depthSuffix}, strLen_{depthSuffix}));");
                        sb.AppendLine($"{indentStr}    {span}[{field.Name}ListOffset{depthSuffix} + strLen_{depthSuffix}] = 0;");
                        sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += strLen_{depthSuffix} + 1;");
                    }
                    else if (arrayElementField.Type is LuminFiledType.Class or LuminFiledType.Struct)
                    {
                        
                        if (arrayElementField.Type is LuminFiledType.Class)
                        {
                            sb.AppendLine($"{indentStr}    if ({fieldPath}[i{depthSuffix}] == null)");
                            sb.AppendLine($"{indentStr}    {{");
                            sb.AppendLine($"{indentStr}        writer.WriteNullObjectHeader(ref {field.Name}ListOffset{depthSuffix});");
                            sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                            sb.AppendLine($"{indentStr}        continue;");
                            sb.AppendLine($"{indentStr}    }}");
                        }
                        
                        
                        foreach (var subField in arrayElementField.ClassFields)
                        {
                            if (subField.FieldType is LuminDataType.Reference)
                            {
                                sb.AppendLine($"{indentStr}    if ({fieldPath}[i{depthSuffix}].{subField.Name} != null)");
                                sb.AppendLine($"{indentStr}    {{");
                                
                                if (subField.Type is LuminFiledType.String) 
                                    sb.AppendLine($"{indentStr}        var {subField.Name}Length = System.Text.Encoding.UTF8.GetByteCount({fieldPath}[i{depthSuffix}].{subField.Name});");
                                GenerateSerializeCode(sb, subField, $"{fieldPath}[i{depthSuffix}].{subField.Name}", span, $"{field.Name}ListOffset{depthSuffix}", indent + 2, depth + 1);
                                sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += {GetFieldLength(subField, depth + 1)};");
                                
                                sb.AppendLine($"{indentStr}    }}");
                                sb.AppendLine($"{indentStr}    else");
                                sb.AppendLine($"{indentStr}    {{");
                                switch (subField.Type)
                                {
                                    case LuminFiledType.Array or LuminFiledType.List:
                                        sb.AppendLine($"{indentStr}        writer.WriteNullCollectionHeader(ref {field.Name}ListOffset{depthSuffix});");
                                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                                        break;
                                    case LuminFiledType.String:
                                        sb.AppendLine($"{indentStr}        writer.WriteNullStringHeader(ref {field.Name}ListOffset{depthSuffix});");
                                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                                        break;
                                    default:
                                        sb.AppendLine($"{indentStr}        writer.WriteNullObjectHeader(ref {field.Name}ListOffset{depthSuffix});");
                                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                                        break;
                                }
                                sb.AppendLine($"{indentStr}    }}");
                            }
                            else
                            {
                                if (subField.Type is LuminFiledType.String) 
                                    sb.AppendLine($"{indentStr}    var {subField.Name}Length = System.Text.Encoding.UTF8.GetByteCount({fieldPath}[i{depthSuffix}].{subField.Name});");
                                GenerateSerializeCode(sb, subField, $"{fieldPath}[i{depthSuffix}].{subField.Name}", span, $"{field.Name}ListOffset{depthSuffix}", indent + 1, depth + 1);
                                sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {GetFieldLength(subField, depth + 1)};");
                            }
                            
                        }
                    }
                    else
                    {
                        
                        
                        if (arrayElementField.Type is LuminFiledType.Array or LuminFiledType.List)
                        {
                            sb.AppendLine($"{indentStr}    if ({fieldPath}[i{depthSuffix}] == null)");
                            sb.AppendLine($"{indentStr}    {{");
                            sb.AppendLine($"{indentStr}        writer.WriteNullCollectionHeader(ref {field.Name}ListOffset{depthSuffix});");
                            sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                            sb.AppendLine($"{indentStr}        continue;");
                            sb.AppendLine($"{indentStr}    }}");
                        }
                        
                        
                        GenerateSerializeCode(
                            sb,
                            arrayElementField,
                            $"{fieldPath}[i{depthSuffix}]",
                            span,
                            $"{field.Name}ListOffset{depthSuffix}",
                            indent + 1,
                            depth + 1
                        );
                        if(arrayElementField.Type is LuminFiledType.List or LuminFiledType.Array) 
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} = {GetFieldLength(arrayElementField, depth + 1)};");
                        else
                        {
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {GetFieldLength(arrayElementField, depth + 1)};");
                        }
                    }
    
                    sb.AppendLine($"{indentStr}}}");
                    break;
                case LuminFiledType.Class:
                case LuminFiledType.Struct:
                    
                    _currentClassName = field.ClassName;
                    
                    sb.AppendLine($"{indentStr}// 序列化{field.ClassName}");
                    
                    for (int i = 0; i < field.ClassFields.Count; i++)
                    {
                        var subField = field.ClassFields[i];
                        
                        if (subField.FieldType is LuminDataType.Reference)
                        {
                            sb.AppendLine($"{indentStr}if ({fieldPath}.{subField.Name} != null)");
                            sb.AppendLine($"{indentStr}{{");
                            
                            if (subField.Type is LuminFiledType.String)
                                sb.AppendLine($"{indentStr}    var {subField.Name}Length = System.Text.Encoding.UTF8.GetByteCount({fieldPath}.{subField.Name});");
                            GenerateSerializeCode(sb, subField, $"{fieldPath}.{subField.Name}", span, offset, indent + 1, depth + 1);
                            
                            sb.AppendLine($"{indentStr}}}");
                            switch (subField.Type)
                            {
                                case LuminFiledType.List or LuminFiledType.Array:
                                    sb.AppendLine($"{indentStr}else");
                                    sb.AppendLine($"{indentStr}{{");
                                    sb.AppendLine($"{indentStr}    writer.WriteNullCollectionHeader(ref {offset});");
                                    sb.AppendLine($"{indentStr}    {offset} += 4;");
                                    sb.AppendLine($"{indentStr}}}"); break;
                                case LuminFiledType.String:
                                    sb.AppendLine($"{indentStr}else");
                                    sb.AppendLine($"{indentStr}{{");
                                    sb.AppendLine($"{indentStr}    writer.WriteNullStringHeader(ref {offset});");
                                    sb.AppendLine($"{indentStr}    {offset} += 1;");
                                    sb.AppendLine($"{indentStr}}}"); break;
                                default:
                                    sb.AppendLine($"{indentStr}else");
                                    sb.AppendLine($"{indentStr}{{");
                                    sb.AppendLine($"{indentStr}    writer.WriteNullObjectHeader(ref {offset});");
                                    sb.AppendLine($"{indentStr}    {offset} += 1;");
                                    sb.AppendLine($"{indentStr}}}"); break;
                            }
                        }
                        else
                        {
                            if (subField.Type is LuminFiledType.String)
                                sb.AppendLine($"{indentStr}var {subField.Name}Length = System.Text.Encoding.UTF8.GetByteCount({fieldPath}.{subField.Name});");
                            
                            GenerateSerializeCode(sb, subField, $"{fieldPath}.{subField.Name}", span, offset, indent, depth + 1);
                        }
                        
                    }
                    break;
                case LuminFiledType.Enum:
                    sb.AppendLine($"{indentStr}Unsafe.WriteUnaligned(ref {span}[{offset}], ({GetEnumTypeName(field.EnumType)}){fieldPath});");
                    break;
                default:
                    throw new ArgumentException($"Unsupported type: {field.Type}");
            }
        }

        private static void GenerateDeserializeCode(
            StringBuilder sb, LuminDataFiled field, 
            string targetObj, string span, 
            string offset, int indent, int depth, 
            bool isFirst = true, string fieldPath = "", bool isArray = false)
        {
            string indentStr = new string(' ', indent * 4);
            string depthSuffix = $"_{depth}";

            switch (field.Type)
            {
                case LuminFiledType.Byte:
                    sb.AppendLine(isFirst 
                        ? $"{indentStr}{targetObj}.{field.Name} = {span}[{offset}];" :
                        isArray ? $"{indentStr}{targetObj}[i_{depth - 1}] = {span}[{offset}];"
                        : $"{indentStr}{targetObj}.Add({span}[{offset}]);");
                    break;
                case LuminFiledType.Bool:
                    if (isFirst) 
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else if (isArray)
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}[i_{depth - 1}]);");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out bool {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj}.Add({field.Name}TempValue{depthSuffix});");
                    }
                    
                    break;
                case LuminFiledType.Short:
                    if (isFirst) 
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else if (isArray)
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}[i_{depth - 1}]);");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out short {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj}.Add({field.Name}TempValue{depthSuffix});");
                    }
                    break;
                case LuminFiledType.Int:
                    if (isFirst) 
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else if (isArray)
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}[i_{depth - 1}]);");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out int {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj}.Add({field.Name}TempValue{depthSuffix});");
                    }
                    break;
                case LuminFiledType.Long:
                    if (isFirst) 
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else if (isArray)
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}[i_{depth - 1}]);");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out long {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj}.Add({field.Name}TempValue{depthSuffix});");
                    }
                    break;
                case LuminFiledType.Float:
                    if (isFirst) 
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else if (isArray)
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}[i_{depth - 1}]);");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out float {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj}.Add({field.Name}TempValue{depthSuffix});");
                    }
                    break;
                case LuminFiledType.Double:
                    if (isFirst) 
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}.{field.Name});");
                    else if (isArray)
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out {targetObj}[i_{depth - 1}]);");
                    else
                    {
                        sb.AppendLine($"{indentStr}reader.ReadUnmanagedWithoutSizeReturn(ref {offset}, out double {field.Name}TempValue{depthSuffix});");
                        sb.AppendLine($"{indentStr}{targetObj}.Add({field.Name}TempValue{depthSuffix});");
                    }
                    break;
                case LuminFiledType.String:
                    sb.AppendLine($"{indentStr}int {field.Name}{depthSuffix}Length = 0;");
                    sb.AppendLine($"{indentStr}while ({span}[{offset} + {field.Name}{depthSuffix}Length] != 0)");
                    sb.AppendLine($"{indentStr}{{");
                    sb.AppendLine($"{indentStr}    {field.Name}{depthSuffix}Length++;");
                    sb.AppendLine($"{indentStr}}}");
                    
                    //sb.AppendLine($"{indentStr}if ({field.Name}{depthSuffix}Length != 0)");
                    //sb.AppendLine($"{indentStr}{{");
                    if (isFirst)
                    {
                        //sb.AppendLine($"{indentStr}    {targetObj}.{field.Name} = System.Text.Encoding.UTF8.GetString({span}.Slice({offset}, {field.Name}{depthSuffix}Length));");
                        sb.AppendLine($"{indentStr}{targetObj}.{field.Name} = reader.ReadString({offset}, {field.Name}{depthSuffix}Length)!;");
                    }
                    else if (isArray)
                    {
                        //sb.AppendLine($"{indentStr}    {targetObj}[i_{depth - 1}] = System.Text.Encoding.UTF8.GetString({span}.Slice({offset}, {field.Name}{depthSuffix}Length));");
                        sb.AppendLine($"{indentStr}{targetObj}[i_{depth - 1}] = reader.ReadString({offset}, {field.Name}{depthSuffix}Length)!;");
                    }
                    else
                    {
                        //sb.AppendLine($"{indentStr}    {targetObj}.Add(System.Text.Encoding.UTF8.GetString({span}.Slice({offset}, {field.Name}{depthSuffix}Length)));");
                        sb.AppendLine($"{indentStr}{targetObj}.Add(reader.ReadString({offset}, {field.Name}{depthSuffix}Length)!);");
                    }
                    //sb.AppendLine($"{indentStr}}}");
                    sb.AppendLine($"{indentStr}{offset} += {field.Name}{depthSuffix}Length + 1;");
                    break;
                case LuminFiledType.List:
                    if (isFirst && depth is 0) 
                        //sb.AppendLine($"{indentStr}int {field.Name}Count{depthSuffix} = Unsafe.ReadUnaligned<int>(ref {span}[{offset}]);");
                        sb.AppendLine($"{indentStr}reader.TryReadCollectionHead(ref {offset}, out int {field.Name}Count{depthSuffix});");
                    
                    var elementField = new LuminDataFiled
                    {
                        Type = ConvertGenericsToFieldType(field.GenericType[0]),
                        GenericType = field.GenericType.Skip(1).ToList(),
                        ClassName = field.ClassName,
                        ClassFields = field.ClassFields,
                        ClassGenericType = field.ClassGenericType,
                    };
                    
                    
                    // 明确泛型类型声明
                    string genericType = GetFullGenericTypeName(field.GenericType, elementField.ClassName, elementField.ClassGenericType);
                    if (isFirst) 
                        sb.AppendLine($"{indentStr}{targetObj}.{field.Name} = new List<{genericType}>({field.Name}Count{depthSuffix});");
                    
                    sb.AppendLine($"{indentStr}int {field.Name}ListOffset{depthSuffix} = {offset} + 4;");
                    
                    if (!IsReferenceGenericType(field.GenericType.FirstOrDefault()))
                    {
                        

                        if (depth > 0)
                        {
                            sb.AppendLine($"{indentStr}var {field.Name}TempSpan{depthSuffix} = LuminPackMarshal.GetListSpan(ref element__{depth - 1}, {field.Name}Count{depthSuffix});");
                            sb.AppendLine($"{indentStr}reader.ReadUnmanagedSpan(ref {offset}, {field.Name}TempSpan{depthSuffix}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                            sb.AppendLine($"{indentStr}LuminPackMarshal.SetListSize(ref element__{depth - 1}, {field.Name}Count{depthSuffix});");
                        }
                        else
                        {
                            sb.AppendLine($"{indentStr}var {field.Name}TempSpan{depthSuffix} = LuminPackMarshal.GetListSpan(ref {targetObj}.{field.Name}!, {field.Name}Count{depthSuffix});");
                            sb.AppendLine($"{indentStr}reader.ReadUnmanagedSpan(ref {offset}, {field.Name}TempSpan{depthSuffix}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                            sb.AppendLine($"{indentStr}LuminPackMarshal.SetListSize(ref {targetObj}.{field.Name}, {field.Name}Count{depthSuffix});");
                        }
                        
                        
                        sb.AppendLine($"{indentStr}{field.Name}ListOffset{depthSuffix} += {field.Name}TempLength{depthSuffix};");
                        
                        return;
                    }
                    
                    if (elementField.Type is LuminFiledType.Struct)
                    {
                        sb.AppendLine($"{indentStr}if (!reader.IsReferenceOrContainsReferences<{field.ClassName}>())");
                        sb.AppendLine($"{indentStr}{{");
                        if (depth > 0)
                        {
                            sb.AppendLine($"{indentStr}    var {field.Name}TempSpan{depthSuffix} = LuminPackMarshal.GetListSpan(ref element__{depth - 1}, {field.Name}Count{depthSuffix});");
                            sb.AppendLine($"{indentStr}    reader.ReadUnmanagedSpan(ref {offset}, {field.Name}TempSpan{depthSuffix}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                            sb.AppendLine($"{indentStr}    LuminPackMarshal.SetListSize(ref element__{depth - 1}, {field.Name}Count{depthSuffix});");
                        }
                        else
                        {
                            sb.AppendLine($"{indentStr}    var {field.Name}TempSpan{depthSuffix} = LuminPackMarshal.GetListSpan(ref {targetObj}.{field.Name}!, {field.Name}Count{depthSuffix});");
                            sb.AppendLine($"{indentStr}    reader.ReadUnmanagedSpan(ref {offset}, {field.Name}TempSpan{depthSuffix}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                            sb.AppendLine($"{indentStr}    LuminPackMarshal.SetListSize(ref {targetObj}.{field.Name}, {field.Name}Count{depthSuffix});");
                        }
                        
                        sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} = {field.Name}TempLength{depthSuffix} + 4;");
                        
                        sb.AppendLine($"{indentStr}}}");
                        
                        sb.AppendLine($"{indentStr}else");
                    }
                    
                    sb.AppendLine($"{indentStr}for (int i{depthSuffix} = 0; i{depthSuffix} < {field.Name}Count{depthSuffix}; i{depthSuffix}++)");
                    sb.AppendLine($"{indentStr}{{");
                    
                    
                    
                    // 处理嵌套列表的初始化
                    if (elementField.Type is LuminFiledType.List)
                    {
                        //sb.AppendLine($"{indentStr}    int {elementField.Name}Count_{depth + 1} = Unsafe.ReadUnaligned<int>(ref {span}[{field.Name}ListOffset{depthSuffix}]);");
                        sb.AppendLine($"{indentStr}    reader.TryReadCollectionHead(ref {offset}, out int {elementField.Name}Count_{depth + 1});");
                        
                        sb.AppendLine($"{indentStr}    if ({elementField.Name}Count_{depth + 1} == LuminPackCode.NullCollection)");
                        sb.AppendLine($"{indentStr}    {{");
                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                        if(isFirst) 
                            sb.AppendLine($"{indentStr}        {targetObj}.{field.Name}.Add(default!);");
                        else
                            sb.AppendLine($"{indentStr}        {targetObj}.Add(default!);");
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                        
                        // 生成嵌套泛型类型名称（例如 List<List<int>>）
                        string nestedGeneric = GetFullGenericTypeName(elementField.GenericType, elementField.ClassName, elementField.ClassGenericType);
                        sb.AppendLine($"{indentStr}    var element_{depthSuffix} = new List<{nestedGeneric}>({elementField.Name}Count_{depth + 1});");
                        
                        if(isFirst) 
                            sb.AppendLine($"{indentStr}    {targetObj}.{field.Name}.Add(element_{depthSuffix});");
                        else
                            sb.AppendLine($"{indentStr}    {targetObj}.Add(element_{depthSuffix});");
                    }
                    else if (elementField.Type is LuminFiledType.Array)
                    {
                        var type = field.GenericType.Last();
                        
                        //sb.AppendLine($"{indentStr}    int {elementField.Name}Count_{depth + 1} = Unsafe.ReadUnaligned<int>(ref {span}[{field.Name}ListOffset{depthSuffix}]);");
                        sb.AppendLine($"{indentStr}    reader.TryReadCollectionHead(ref {offset}, out int {elementField.Name}Count_{depth + 1});");
                        
                        sb.AppendLine($"{indentStr}    if ({elementField.Name}Count_{depth + 1} == LuminPackCode.NullCollection)");
                        sb.AppendLine($"{indentStr}    {{");
                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                        if(isFirst) 
                            sb.AppendLine($"{indentStr}        {targetObj}.{field.Name}.Add(default!);");
                        else
                            sb.AppendLine($"{indentStr}        {targetObj}.Add(default!);");
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                        StringBuilder array = new StringBuilder($"[{elementField.Name}Count_{depth + 1}]");

                        for (var i = 1; i < field.GenericType.Count; i++)
                        {
                            if (field.GenericType[i] is not LuminGenericsType.Array) break;
                            array.Append("[]");
                        }
                        
                        if (type is not LuminGenericsType.Struct and not LuminGenericsType.Class) 
                            sb.AppendLine($"{indentStr}    var element_{depthSuffix} = new {GetGenericTypeName(type)}{array};");
                        else
                            sb.AppendLine($"{indentStr}    var element_{depthSuffix} = new {field.ClassName}{array};");
                        
                        if(isFirst) 
                            sb.AppendLine($"{indentStr}    {targetObj}.{field.Name}.Add(element_{depthSuffix});");
                        else
                            sb.AppendLine($"{indentStr}    {targetObj}.Add(element_{depthSuffix});");
                    }
                    else if (elementField.Type is LuminFiledType.Class)
                    {
                        sb.AppendLine($"{indentStr}    if (reader.PeekIsNullObject(ref {field.Name}ListOffset{depthSuffix}))");
                        sb.AppendLine($"{indentStr}    {{");
                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                        if(isFirst) 
                            sb.AppendLine($"{indentStr}        {targetObj}.{field.Name}.Add(default!);");
                        else
                            sb.AppendLine($"{indentStr}        {targetObj}.Add(default!);");
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                    }
                    
                    string elementPath;
                    // 递归反序列化元素
                    if (elementField.Type is LuminFiledType.List or LuminFiledType.Array)
                    {
                        elementPath = isFirst ? $"{targetObj}.{field.Name}[i{depthSuffix}]" : $"{targetObj}[i{depthSuffix}]";
                    }
                    else
                    {
                        elementPath = isFirst ? $"{targetObj}.{field.Name}" : $"{targetObj}";
                    }
                    
                    GenerateDeserializeCode(
                        sb, 
                        elementField, 
                        elementPath,
                        span, 
                        $"{field.Name}ListOffset{depthSuffix}", 
                        indent + 1, 
                        depth + 1, 
                        false,
                        elementPath
                    );
                    
                    
                    
                    // 更新偏移量
                    if (elementField.Type is not LuminFiledType.String and not LuminFiledType.Class and not LuminFiledType.Struct) 
                        if(elementField.Type is LuminFiledType.List or LuminFiledType.Array) 
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} = {GetFieldLength(elementField, depth + 1)};");
                        else
                        {
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {GetFieldLength(elementField, depth + 1)};");
                        }
                    sb.AppendLine($"{indentStr}}}");
                    
                    break;
                case LuminFiledType.Array:
                    
                    if (isFirst) 
                        //sb.AppendLine($"{indentStr}int {field.Name}Count{depthSuffix} = Unsafe.ReadUnaligned<int>(ref {span}[{offset}]);");
                        sb.AppendLine($"{indentStr}reader.TryReadCollectionHead(ref {offset}, out int {field.Name}Count{depthSuffix});");
                    
                    var arrayElementField = new LuminDataFiled
                    {
                        Type = ConvertGenericsToFieldType(field.GenericType[0]),
                        GenericType = field.GenericType.Skip(1).ToList(),
                        ClassName = field.ClassName,
                        ClassFields = field.ClassFields,
                        ClassGenericType = field.ClassGenericType,
                    };

                    StringBuilder arrayNum = new StringBuilder($"[{field.Name}Count{depthSuffix}]");

                    for (var i = 0; i < field.GenericType.Count; i++)
                    {
                        if (field.GenericType[i] is not LuminGenericsType.Array) break;
                        arrayNum.Append("[]");
                    }

                    if (isFirst)
                    {
                        var type = field.GenericType.Last();
                        if (type is not LuminGenericsType.Struct and not LuminGenericsType.Class) 
                            sb.AppendLine($"{indentStr}{targetObj}.{field.Name} = new {GetGenericTypeName(type)}{arrayNum};");
                        else
                            sb.AppendLine($"{indentStr}{targetObj}.{field.Name} = new {field.ClassName}{arrayNum};");
                    }
                        
                    
                    sb.AppendLine($"{indentStr}int {field.Name}ListOffset{depthSuffix} = {offset} + 4;");
                    
                    if (!IsReferenceGenericType(field.GenericType.FirstOrDefault()))
                    {
                        if (depth > 0) 
                            sb.AppendLine($"{indentStr}reader.ReadUnmanagedArray(ref {offset}, ref element__{depth - 1}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                        else
                            sb.AppendLine($"{indentStr}reader.ReadUnmanagedArray(ref {offset}, ref {targetObj}.{field.Name}!, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                        
                        sb.AppendLine($"{indentStr}{field.Name}ListOffset{depthSuffix} += {field.Name}TempLength{depthSuffix};");
                        
                        return;
                    }
                    
                    if (arrayElementField.Type is LuminFiledType.Struct)
                    {
                        sb.AppendLine($"{indentStr}if (!reader.IsReferenceOrContainsReferences<{field.ClassName}>())");
                        sb.AppendLine($"{indentStr}{{");
                        if (depth > 0) 
                            sb.AppendLine($"{indentStr}    reader.ReadUnmanagedArray(ref {offset}, ref element__{depth - 1}, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                        else
                            sb.AppendLine($"{indentStr}    reader.ReadUnmanagedArray(ref {offset}, ref {targetObj}.{field.Name}!, {field.Name}Count{depthSuffix}, out var {field.Name}TempLength{depthSuffix});");
                        
                        sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {field.Name}TempLength{depthSuffix};");
                        
                        sb.AppendLine($"{indentStr}}}");
                        
                        sb.AppendLine($"{indentStr}else");
                    }
                    
                    sb.AppendLine($"{indentStr}for (int i{depthSuffix} = 0; i{depthSuffix} < {field.Name}Count{depthSuffix}; i{depthSuffix}++)");
                    sb.AppendLine($"{indentStr}{{");
                    
                    if (arrayElementField.Type is LuminFiledType.List)
                    {
                        //sb.AppendLine($"{indentStr}    int {arrayElementField.Name}Count_{depth + 1} = Unsafe.ReadUnaligned<int>(ref {span}[{field.Name}ListOffset{depthSuffix}]);");
                        sb.AppendLine($"{indentStr}    reader.TryReadCollectionHead(ref {offset}, out int {arrayElementField.Name}Count_{depth + 1});");
                        
                        sb.AppendLine($"{indentStr}    if ({arrayElementField.Name}Count_{depth + 1} == LuminPackCode.NullCollection)");
                        sb.AppendLine($"{indentStr}    {{");
                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                        
                        // 生成嵌套泛型类型名称（例如 List<List<int>>）
                        string nestedGeneric = GetFullGenericTypeName(arrayElementField.GenericType, arrayElementField.ClassName, arrayElementField.ClassGenericType);
                        sb.AppendLine($"{indentStr}    var element_{depthSuffix} = new List<{nestedGeneric}>({arrayElementField.Name}Count_{depth + 1});");
                        
                        if(isFirst) 
                            sb.AppendLine($"{indentStr}    {targetObj}.{field.Name}.Add(element_{depthSuffix});");
                        else
                            sb.AppendLine($"{indentStr}    {targetObj}.Add(element_{depthSuffix});");
                    }
                    else if (arrayElementField.Type is LuminFiledType.Array)
                    {
                        //sb.AppendLine($"{indentStr}    int {arrayElementField.Name}Count_{depth + 1} = Unsafe.ReadUnaligned<int>(ref {span}[{field.Name}ListOffset{depthSuffix}]);");
                        sb.AppendLine($"{indentStr}    reader.TryReadCollectionHead(ref {offset}, out int {arrayElementField.Name}Count_{depth + 1});");
                        
                        sb.AppendLine($"{indentStr}    if ({arrayElementField.Name}Count_{depth + 1} == LuminPackCode.NullCollection)");
                        sb.AppendLine($"{indentStr}    {{");
                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 4;");
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                        
                        StringBuilder array = new StringBuilder($"[{arrayElementField.Name}Count_{depth + 1}]");

                        for (var i = 1; i < field.GenericType.Count; i++)
                        {
                            if (field.GenericType[i] is not LuminGenericsType.Array) break;
                            array.Append("[]");
                        }
                        var type = field.GenericType.Last();
                        if (type is not LuminGenericsType.Struct and not LuminGenericsType.Class) 
                            sb.AppendLine($"{indentStr}    var element_{depthSuffix} = new {GetGenericTypeName(type)}{array};");
                        else
                            sb.AppendLine($"{indentStr}    var element_{depthSuffix} = new {field.ClassName}{array};");
                        
                        var targetObject = isFirst ? $"{targetObj}.{field.Name}[i{depthSuffix}]" : $"{targetObj}[i{depthSuffix}]";
                        sb.AppendLine($"{indentStr}    {targetObject} = element_{depthSuffix};");
                    }
                    else if (arrayElementField.Type is LuminFiledType.Class)
                    {
                        sb.AppendLine($"{indentStr}    if (reader.PeekIsNullObject(ref {field.Name}ListOffset{depthSuffix}))");
                        sb.AppendLine($"{indentStr}    {{");
                        sb.AppendLine($"{indentStr}        {field.Name}ListOffset{depthSuffix} += 1;");
                        sb.AppendLine($"{indentStr}        continue;");
                        sb.AppendLine($"{indentStr}    }}");
                    }
                    
                    
                    string arrayElementPath;
                    // 递归反序列化元素
                    if (arrayElementField.Type == LuminFiledType.Array)
                    {
                        arrayElementPath = isFirst ? $"{targetObj}.{field.Name}[i{depthSuffix}]" : $"{targetObj}[i{depthSuffix}]";
                    }
                    else
                    {
                        arrayElementPath = isFirst ? $"{targetObj}.{field.Name}" : $"{targetObj}";
                    }
                    
                    GenerateDeserializeCode(
                        sb, 
                        arrayElementField, 
                        arrayElementPath,
                        span, 
                        $"{field.Name}ListOffset{depthSuffix}", 
                        indent + 1, 
                        depth + 1, 
                        false,
                        arrayElementPath,
                        true
                    );
                    
                    
                    
                    // 更新偏移量
                    if (arrayElementField.Type is not LuminFiledType.String and not LuminFiledType.Class and not LuminFiledType.Struct) 
                        if(arrayElementField.Type is LuminFiledType.Array or LuminFiledType.List) 
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} = {GetFieldLength(arrayElementField, depth + 1)};");
                        else
                        {
                            sb.AppendLine($"{indentStr}    {field.Name}ListOffset{depthSuffix} += {GetFieldLength(arrayElementField, depth + 1)};");
                        }
                    sb.AppendLine($"{indentStr}}}");
                    
                    break;
                case LuminFiledType.Class:
                case LuminFiledType.Struct:
                    
                    _currentClassName = field.ClassName;
                    
                    sb.AppendLine($"{indentStr}// 反序列化{field.ClassName}");
                    sb.AppendLine($"{indentStr}var {field.Name}Temp = new {GetFullTypeName(field)}();");

                    for (int i = 0; i < field.ClassFields.Count; i++)
                    {
                        var subField = field.ClassFields[i];

                        switch (subField.Type)
                        {
                            case LuminFiledType.Array or LuminFiledType.List:
                                sb.AppendLine($"{indentStr}if (reader.PeekIsNullCollection(ref {offset}))");
                                sb.AppendLine($"{indentStr}{{");
                                sb.AppendLine($"{indentStr}    {offset} += 4;");
                                sb.AppendLine($"{indentStr}}}"); break;
                            case LuminFiledType.Class:
                                sb.AppendLine($"{indentStr}if (reader.PeekIsNullObject(ref {offset}))");
                                sb.AppendLine($"{indentStr}{{");
                                sb.AppendLine($"{indentStr}    {offset} += 1;");
                                sb.AppendLine($"{indentStr}}}"); break;
                        }
                        
                        
                        
                        GenerateDeserializeCode(sb, subField, $"{field.Name}Temp", span, offset, indent, depth + 1);
                        if (field.ClassFields[i].Type 
                            is not LuminFiledType.String 
                            and not LuminFiledType.Class 
                            and not LuminFiledType.Struct
                            && depth > 0) 
                            sb.AppendLine($"{indentStr}{offset} += {GetFieldLength(subField, depth + 1)};");
                    }
                    

                    if (isFirst)
                        sb.AppendLine($"{indentStr}{targetObj}.{field.Name} = {field.Name}Temp;");
                    else if (isArray)
                        sb.AppendLine($"{indentStr}{targetObj}[i_{depth - 1}] = {field.Name}Temp;");
                    else
                        sb.AppendLine($"{indentStr}{targetObj}.Add({field.Name}Temp);");
                    break;
                case LuminFiledType.Enum:
                    sb.AppendLine($"{indentStr}{targetObj}.{field.Name} = ({GetEnumTypeName(field)})Unsafe.ReadUnaligned<int>(ref {span}[{offset}]);");
                    break;
                default:
                    throw new ArgumentException($"Unsupported type: {field.Type}");
            }
        }

        private static string GetEnumTypeName(LuminDataFiled field)
        {
            return $"{field.EnumType}";
        }

        private static string GetFullTypeName(LuminDataFiled field)
        {
            if (field.Type is LuminFiledType.Class or LuminFiledType.Struct)
            {
                var sb = new StringBuilder();
                if (!string.IsNullOrEmpty(field.NameSpace) && field.NameSpace != "Your Data NameSpace")
                {
                    sb.Append($"{field.NameSpace}.");
                }
                sb.Append(field.ClassName); // 使用ClassName替代Name
                
                if (!string.IsNullOrEmpty(field.ClassGenericType))
                {
                    sb.Append("<");
                    sb.Append(field.ClassGenericType);
                    sb.Append(">");
                }
                
                return sb.ToString();
            }
            return field.Type.ToString();
        }

        private static LuminFiledType ConvertGenericsToFieldType(LuminGenericsType genericType)
        {
            return genericType switch
            {
                LuminGenericsType.Byte => LuminFiledType.Byte,
                LuminGenericsType.Short => LuminFiledType.Short,
                LuminGenericsType.Int => LuminFiledType.Int,
                LuminGenericsType.Long => LuminFiledType.Long,
                LuminGenericsType.Float => LuminFiledType.Float,
                LuminGenericsType.Double => LuminFiledType.Double,
                LuminGenericsType.String => LuminFiledType.String,
                LuminGenericsType.Bool => LuminFiledType.Bool,
                LuminGenericsType.Class => LuminFiledType.Class,
                LuminGenericsType.Struct => LuminFiledType.Struct,
                LuminGenericsType.List => LuminFiledType.List,
                LuminGenericsType.Array => LuminFiledType.Array,
                LuminGenericsType.Enum => LuminFiledType.Enum,
                _ => throw new ArgumentException("Unsupported generic type")
            };
        }
        
        private static LuminFiledType ConvertGenericsToFieldType(List<LuminGenericsType> genericTypes)
        {
            if (genericTypes.Count == 0)
                throw new ArgumentException("Empty generic types");

            var currentType = genericTypes[0];
            if (currentType == LuminGenericsType.List)
            {
                if (genericTypes.Count < 2)
                    throw new ArgumentException("Insufficient generic parameters for List");
                // 递归剥离泛型参数，直到找到非列表类型
                return ConvertGenericsToFieldType(genericTypes.Skip(1).ToList());
            }
            return currentType switch
            {
                LuminGenericsType.Byte => LuminFiledType.Byte,
                LuminGenericsType.Short => LuminFiledType.Short,
                LuminGenericsType.Int => LuminFiledType.Int,
                LuminGenericsType.Long => LuminFiledType.Long,
                LuminGenericsType.Float => LuminFiledType.Float,
                LuminGenericsType.Double => LuminFiledType.Double,
                LuminGenericsType.Bool => LuminFiledType.Bool,
                LuminGenericsType.String => LuminFiledType.String,
                LuminGenericsType.Class => LuminFiledType.Class,
                LuminGenericsType.Struct => LuminFiledType.Struct,
                LuminGenericsType.Enum => LuminFiledType.Enum,
                _ => throw new ArgumentException("Unsupported generic type")
            };
        }

        private static string GetGenericTypeName(LuminGenericsType genericType)
        {
            return genericType switch
            {
                LuminGenericsType.Short => "short",
                LuminGenericsType.Int => "int",
                LuminGenericsType.Long => "long",
                LuminGenericsType.Float => "float",
                LuminGenericsType.Double => "double",
                LuminGenericsType.String => "string",
                LuminGenericsType.Bool => "bool",
                LuminGenericsType.List => "List",
                LuminGenericsType.Enum => "Enum",
                _ => genericType.ToString()
            };
        }
        
        private static string GetEnumTypeName(LuminEnumFieldType genericType)
        {
            return genericType switch
            {
                LuminEnumFieldType.Byte => "byte",
                LuminEnumFieldType.Short => "short",
                LuminEnumFieldType.Int => "int",
                LuminEnumFieldType.Long => "long",
                LuminEnumFieldType.Float => "float",
                LuminEnumFieldType.Double => "double",
                _ => throw new ArgumentException("Unsupported generic type")
            };
        }

        private static string GetFieldLength(LuminDataFiled field, int depth)
        {
            string depthSuffix = $"_{depth}";
            return field.Type switch
            {
                LuminFiledType.Byte => "1",
                LuminFiledType.Short => "2",
                LuminFiledType.Int => "4",
                LuminFiledType.Long => "8",
                LuminFiledType.Float => "4",
                LuminFiledType.Double => "8",
                LuminFiledType.Bool => "1",
                LuminFiledType.String => $"{field.Name}Length + 1",
                LuminFiledType.List or LuminFiledType.Array => $"{field.Name}ListOffset{depthSuffix}",
                LuminFiledType.Class or LuminFiledType.Struct =>
                    string.Join(" + ", field.ClassFields.Select(sub => GetFieldLength(sub, depth + 1))),
                LuminFiledType.Enum => GetEnumFieldLength(field.EnumType),
                _ => throw new ArgumentException($"Unsupported type: {field.Type}")
            };
        }
        

        private static string GetEnumFieldLength(LuminEnumFieldType enumField)
        {
            return enumField switch
            {
                LuminEnumFieldType.Byte => "1",
                LuminEnumFieldType.Short => "2",
                LuminEnumFieldType.Int => "4",
                LuminEnumFieldType.Long => "8",
                LuminEnumFieldType.Float => "4",
                LuminEnumFieldType.Double => "8",
                _ => throw new ArgumentException($"Unsupported type: {enumField}")
            };
        }

        private static string GetListLength(LuminDataFiled field, int depth)
        {
            string depthSuffix = $"_{depth}";
            var type = field.GenericType.Last();
            return type switch
            {
                LuminGenericsType.Byte => $"4 + {field.Name}Count{depthSuffix} * 1",
                LuminGenericsType.Bool => $"4 + ({field.Name}Count{depthSuffix} * 1)",
                LuminGenericsType.Short => $"4 + ({field.Name}Count{depthSuffix} * 2)",
                LuminGenericsType.Int => $"4 + ({field.Name}Count{depthSuffix} * 4)",
                LuminGenericsType.Long => $"4 + ({field.Name}Count{depthSuffix} * 8)",
                LuminGenericsType.Float => $"4 + ({field.Name}Count{depthSuffix} * 4)",
                LuminGenericsType.Double => $"4 + ({field.Name}Count{depthSuffix} * 8)",
                LuminGenericsType.String => $"4 + {field.Name}Count{depthSuffix} * ({field.Name}Count{depthSuffix} + 1)",
                LuminGenericsType.Class => $"4 + {field.Name}Count{depthSuffix} * {field.Name}Count{depthSuffix}",
                LuminGenericsType.Struct => $"4 + {field.Name}Count{depthSuffix} * {field.Name}Count{depthSuffix}",
                LuminGenericsType.List => $"4 + {field.Name}Count{depthSuffix} * {field.Name}Count{depthSuffix}",
                LuminGenericsType.Enum => $"4 + {field.Name}Count{depthSuffix} * {GetEnumFieldLength(field.EnumType)}",
                _ => throw new ArgumentException($"Unsupported generic type: {type}")
            };
        }
        
        private static string GetFullGenericTypeName(List<LuminGenericsType> genericTypes, string classname = "", string genericType = "")
        {
            if (genericTypes.Count == 0) throw new ArgumentException("Empty generic types");
            var currentType = genericTypes[0];
            if (currentType == LuminGenericsType.List)
            {
                return $"List<{GetFullGenericTypeName(genericTypes.Skip(1).ToList())}>";
            }
            
            if (currentType == LuminGenericsType.Array)
            {
                string elementType = GetFullGenericTypeName(
                    genericTypes.Skip(1).ToList(), 
                    classname,
                    genericType
                );
                return $"{elementType}[]"; // 添加数组后缀
            }

            if (classname is not "" and not "Your Class Name")
            {
                if (genericType is "" || string.IsNullOrEmpty(genericType))
                {
                    return currentType switch
                    {
                        LuminGenericsType.Class => classname,
                        LuminGenericsType.Struct => classname,
                        _ => classname
                    };
                }
                
                return currentType switch
                {
                    LuminGenericsType.Class => $"{classname}<{genericType}>",
                    LuminGenericsType.Struct => $"{classname}<{genericType}>",
                    _ => $"{classname}<{genericType}>"
                };
                
            }
            
            return GetGenericTypeName(currentType);
        }

        private static bool IsReferenceGenericType(LuminGenericsType? genericType) => genericType switch
        {
            LuminGenericsType.Byte => false,
            LuminGenericsType.Bool => false,
            LuminGenericsType.Short => false,
            LuminGenericsType.Int => false,
            LuminGenericsType.Long => false,
            LuminGenericsType.Float => false,
            LuminGenericsType.Double => false,
            LuminGenericsType.Enum => false,
            LuminGenericsType.String => true,
            LuminGenericsType.Class => true,
            LuminGenericsType.Struct => true,
            LuminGenericsType.List => true,
            LuminGenericsType.Array => true,
            LuminGenericsType.Null => true
        };
        
        private static bool IsReferenceFiledType(LuminFiledType filedType) => filedType switch
        {
            LuminFiledType.Byte => false,
            LuminFiledType.Bool => false,
            LuminFiledType.Short => false,
            LuminFiledType.Int => false,
            LuminFiledType.Long => false,
            LuminFiledType.Float => false,
            LuminFiledType.Double => false,
            LuminFiledType.String => true,
            LuminFiledType.Class => true,
            LuminFiledType.Struct => true,
            LuminFiledType.List => true,
            LuminFiledType.Array => true,
            LuminFiledType.Enum => false,
            _ => throw new ArgumentException($"Unsupported generic type: {filedType}")
        };

        private static bool IsUnmanagedFiledType(LuminFiledType filedType) => filedType switch
        {
            LuminFiledType.Byte => true,
            LuminFiledType.Bool => true,
            LuminFiledType.Short => true,
            LuminFiledType.Int => true,
            LuminFiledType.Long => true,
            LuminFiledType.Float => true,
            LuminFiledType.Double => true,
            _ => false
        };
        
        private static bool IsFixedLengthType(LuminFiledType type)
        {
            return type switch
            {
                LuminFiledType.Byte    => true,
                LuminFiledType.Short   => true,
                LuminFiledType.Int     => true,
                LuminFiledType.Long    => true,
                LuminFiledType.Float   => true,
                LuminFiledType.Double  => true,
                LuminFiledType.Bool    => true,
                LuminFiledType.Enum    => true,
                _                      => false // String/List/Class/Struct 为可变长度
            };
        }

        // 获取固定长度类型的字节长度表达式
        private static string GetFixedFieldLength(LuminDataFiled field)
        {
            return field.Type switch
            {
                LuminFiledType.Byte    => "1",
                LuminFiledType.Short   => "2",
                LuminFiledType.Int     => "4",
                LuminFiledType.Long    => "8",
                LuminFiledType.Float   => "4",
                LuminFiledType.Double  => "8",
                LuminFiledType.Bool    => "1",
                LuminFiledType.Enum    => GetEnumFieldLength(field.EnumType),
                _ => throw new ArgumentException("非固定长度类型")
            };
        }
        
        // 获取数组维度（例如GenericType=[Array, Array, Int]返回2）
        private static int GetArrayDepth(List<LuminGenericsType> genericTypes)
        {
            int depth = 0;
            foreach (var type in genericTypes)
            {
                if (type == LuminGenericsType.Array) depth++;
                else break;
            }
            return depth;
        }

        // 生成数组类型名称（例如int[][]）
        private static string GetArrayTypeName(List<LuminGenericsType> genericTypes)
        {
            int depth = GetArrayDepth(genericTypes);
            var elementType = genericTypes.Last();
            string typeName = elementType switch
            {
                LuminGenericsType.Int => "int",
                LuminGenericsType.String => "string",
                // 其他类型映射...
                _ => "object"
            };
            return $"{typeName}{new string('[', depth)}{new string(']', depth)}";
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int FindNextUnmanagedType(LuminDataInfo data, int index)
        {
            for (var i = index + 1; i < data.fields.Count; i++)
            {
                if (!IsUnmanagedFiledType(data.fields[i].Type)) break;
                
                index++;
            }
            
            return index;
        }
    }
    
}